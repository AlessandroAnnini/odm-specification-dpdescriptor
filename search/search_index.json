{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"Markdown_Sandbox/","text":"Markdown Sandbox \u2693\ufe0e Usiamo questa pagina per fare esperimenti Tip Si possono fare in modo semplice anche i blocchi, dettagli qui Example Anche le icone si inseriscono facilmente , anche nei link","title":"Markdown Sandbox"},{"location":"Markdown_Sandbox/#markdown-sandbox","text":"Usiamo questa pagina per fare esperimenti Tip Si possono fare in modo semplice anche i blocchi, dettagli qui Example Anche le icone si inseriscono facilmente , anche nei link","title":"Markdown Sandbox"},{"location":"embedding/","text":"Human Readable JSON Schema \u2693\ufe0e","title":"Embedding"},{"location":"embedding/#human-readable-json-schema","text":"","title":"Human Readable JSON Schema"},{"location":"site_index/","text":"","title":"Site index"},{"location":"community/","text":"Community \u2693\ufe0e Contributors \u2693\ufe0e TODO Contact us Quantyca \u2693\ufe0e Quantyca is a technology consulting company specialized in Data and Metadata Management. We work with all business and IT functions to help our customers become more competitive, exploiting the potential made available by new technologies. All the services we offer are targeted to extract the maximum value from the data realizing data platforms that are responsive, resilient, and able to evolve over time. With over 100 active successful projects, we are a reliable partner to support companies: we build together with our customers solutions that can grow and produce value over time. We design, develop and maintain hybrid data and integration platforms for data management throughout the life cycle, from ingestion to exploitation, along with all the integration phases. We also offer customized training and consulting services to support our customers in defining and implementing their data strategy. Quantyca\u2019s team consists of 80+ highly specialized consultants with strong skills in Data Engineering, Advanced Analytics, Software Engineering, Project Management, Software Reliability Engineering (SRE). We have constantly improved our technology portfolio and invested in technical excellence on the tools and products that we selected: we currently have more than 90 active certifications. We also establish a deep relationship with the Data Management and Cloud technology vendors. Blindata \u2693\ufe0e Blindata is a platform for the governance of data assets and enterprise processes.It provides a collaborative solution to address data governance issues in an integrated vision with the needs of regulatory compliance. Blindata covers all the functions of a Data Governance program: Business Glossary, Data Catalog, Data Lineage & Data Stewardship build an integrated and complete view on your Data. Data Classification module gives a semantic meaning to the data while the Data Quality module improves the reliability and trust on data. Moreover, privacy compliance can leverage specific features: registry of processing activities, centralized privacy note management, consent registry with Blockchain integrated notarization.","title":"Community"},{"location":"community/#community","text":"","title":"Community"},{"location":"community/#contributors","text":"TODO Contact us","title":"Contributors"},{"location":"community/#quantyca","text":"Quantyca is a technology consulting company specialized in Data and Metadata Management. We work with all business and IT functions to help our customers become more competitive, exploiting the potential made available by new technologies. All the services we offer are targeted to extract the maximum value from the data realizing data platforms that are responsive, resilient, and able to evolve over time. With over 100 active successful projects, we are a reliable partner to support companies: we build together with our customers solutions that can grow and produce value over time. We design, develop and maintain hybrid data and integration platforms for data management throughout the life cycle, from ingestion to exploitation, along with all the integration phases. We also offer customized training and consulting services to support our customers in defining and implementing their data strategy. Quantyca\u2019s team consists of 80+ highly specialized consultants with strong skills in Data Engineering, Advanced Analytics, Software Engineering, Project Management, Software Reliability Engineering (SRE). We have constantly improved our technology portfolio and invested in technical excellence on the tools and products that we selected: we currently have more than 90 active certifications. We also establish a deep relationship with the Data Management and Cloud technology vendors.","title":"Quantyca"},{"location":"community/#blindata","text":"Blindata is a platform for the governance of data assets and enterprise processes.It provides a collaborative solution to address data governance issues in an integrated vision with the needs of regulatory compliance. Blindata covers all the functions of a Data Governance program: Business Glossary, Data Catalog, Data Lineage & Data Stewardship build an integrated and complete view on your Data. Data Classification module gives a semantic meaning to the data while the Data Quality module improves the reliability and trust on data. Moreover, privacy compliance can leverage specific features: registry of processing activities, centralized privacy note management, consent registry with Blockchain integrated notarization.","title":"Blindata"},{"location":"concepts/","text":"General Concepts \u2693\ufe0e Before to deep dive in the Data Product Descriptor Specification (DPDS) it's important to set the stage introducing some general concepts. Most of them are related to data mesh paradigm . This page anyway IS NOT a data mesh guide. It just positionates some data mesh concepts in the scope of this specification to avoid possible source of ambiguity. Check the Data Mesh Resources page to find out better resources to start learn more about data mesh.","title":"Concepts Intro"},{"location":"concepts/#general-concepts","text":"Before to deep dive in the Data Product Descriptor Specification (DPDS) it's important to set the stage introducing some general concepts. Most of them are related to data mesh paradigm . This page anyway IS NOT a data mesh guide. It just positionates some data mesh concepts in the scope of this specification to avoid possible source of ambiguity. Check the Data Mesh Resources page to find out better resources to start learn more about data mesh.","title":"General Concepts"},{"location":"concepts/data-contract/","text":"Data Contract \u2693\ufe0e It's a formal agreement between the data producer and the data consumers. There is not yet a clear definition of the form and scope of a data contract. Usually they cover the structure of the exchanged data (i.e. the schema) and it's meaning (i.e. the semantic). Check the Data Mesh Resources page for more information on data contracts. In the DPDS the more general concept of service agreements is used in place of data contracts. Data cotracts are infact just a particular type of service agreements because on one side there are services that do not expose data and on the other there are agreements that are not contracts. In particular DPDS uses the following concepts of promises theory to formally describe the interface components of a data product (i.e. data product's ports): Promises: Through promises the data product declares the intent of the port. Promises are not a guarantee of the outcome but the data product will behave accordingly to them in order to realize its intent. The more a data product keeps its promises over time and the more trustworthy it is. Thus, the more trustworthy a data product is the more potential consumers are likely to use it. Trust is based on the verification of how good a data product was in the past in keeping its promises. This verification should be automated by the underlying platform and synthetized in a trust score shared with all potential consumers. Example of promises are: description of services' API, SLO, deprecation policy, etc.. Expectations: Through expectations the data product declares how it wants the port to be used by its consumers. Expectations are the inverse of promises. They are a way to explicitly state what promises the data product would like consumers to make regarding how they will use the port. Example of expectations are: intended usage, intended audience, etc.. Contracts: Through contracts the data product declares promises and expectations that must be respected both by itself and its consumers respectively. A contract is an explicit agreement between the data product and its consumers. It is used to group all the promises and expectations that if not respected can generate penalties like monetary sanctions or interruption of service. Example of contracts are: terms of conditions, SLA, billing policy, etc..","title":"Data Contract"},{"location":"concepts/data-contract/#data-contract","text":"It's a formal agreement between the data producer and the data consumers. There is not yet a clear definition of the form and scope of a data contract. Usually they cover the structure of the exchanged data (i.e. the schema) and it's meaning (i.e. the semantic). Check the Data Mesh Resources page for more information on data contracts. In the DPDS the more general concept of service agreements is used in place of data contracts. Data cotracts are infact just a particular type of service agreements because on one side there are services that do not expose data and on the other there are agreements that are not contracts. In particular DPDS uses the following concepts of promises theory to formally describe the interface components of a data product (i.e. data product's ports): Promises: Through promises the data product declares the intent of the port. Promises are not a guarantee of the outcome but the data product will behave accordingly to them in order to realize its intent. The more a data product keeps its promises over time and the more trustworthy it is. Thus, the more trustworthy a data product is the more potential consumers are likely to use it. Trust is based on the verification of how good a data product was in the past in keeping its promises. This verification should be automated by the underlying platform and synthetized in a trust score shared with all potential consumers. Example of promises are: description of services' API, SLO, deprecation policy, etc.. Expectations: Through expectations the data product declares how it wants the port to be used by its consumers. Expectations are the inverse of promises. They are a way to explicitly state what promises the data product would like consumers to make regarding how they will use the port. Example of expectations are: intended usage, intended audience, etc.. Contracts: Through contracts the data product declares promises and expectations that must be respected both by itself and its consumers respectively. A contract is an explicit agreement between the data product and its consumers. It is used to group all the promises and expectations that if not respected can generate penalties like monetary sanctions or interruption of service. Example of contracts are: terms of conditions, SLA, billing policy, etc..","title":"Data Contract"},{"location":"concepts/data-product-descriptor/","text":"Data Product Descriptor \u2693\ufe0e It's the document that serve as an entry to all the information about a data product , including its fully qualified name, owner, domain, version, interface components and internal components . It is used to share a complete view of the data product between consumers and the underlying DataOps platform throughout all its lifecycle. The objective of DPDS is to provide a standard to define the structure and content of this document. Interface Components \u2693\ufe0e The interfaces exposed to external agents by a data product . These interfaces are grouped by functional role in entities named port . Each port exposes a service or set of correlated services. These are the five types of port supported by the DPSD: Input port(s): an input port describes a set of services exposed by a data product to collect its source data and makes it available for further internal transformation. An input port can receive data from one ore more upstream sources in a push (i.e. asynchronous subscription) or pop mode (i.e. synchronous query). Each data product may have one or more input ports. Output port(s): an output port describes a set of services exposed by a data product to share the generated data in a way that can be understood and trusted. Each data product may have one or more output ports. Discovery port(s): a discovery port describes a set of services exposed by a data product to provide information about its static role in the overall architecture like purpose, structure, location, etc.. Each data product may have one or multiple discovery ports. Observability port(s): an observability port describes a set of services exposed by a data product to provide information about its dynamic behaviour in the overall architecture like logs, traces, audit trails, metrics, etc.. Each data product may have one or more observability ports. Control port(s): a control port describes a set of services exposed by a data product to configure local policies or perform highly privileged governance operations. Each data product may have one or more control ports. Internal Components \u2693\ufe0e Application Components \u2693\ufe0e The components of a data product that implement the services exposed through its ports (i.e. pipelines, microservices, etc..). In DPDS an application component is mainly described through parametrized templates that formally define how to build and deploy the specific application component (i.e. pipeline as code ). In partircular there is one template and configurations attribute pair that describe the application build pipeline and one that describe the application deployment pipeline. These two pairs of attributes should respectvelly be passed by the Data Product Experience Plane to the proper implementation of build service and deploymet service exposed by the Infrastructure Utility Plane . The template attributes contain the definition of the pipeline that can be executed in order to build or deploy the application. The configurations attributes contain the parameters that should be passed at execution time to the build or deployment service. The form of template and configuration attributes depends on the target build or deployment service implementation exposed by the Infrastructure Utility Plane and referenced in the descriptor. The DPDS does not enforce any specific format. NOTE: TODO mettere immagine Infrastructural Components \u2693\ufe0e The components of a data product related to the infrastructural resources (i.e. storage, compute, etc..) used to run its application components. In DPDS an infrastructural component is mainly described through a parametrized template that formally define how to provision the specific infrastructural component (i.e. infrastructure as code). In partircular there is one template attribute that define how to provision the component and one configurations attribute that contains the parameters that should be passed at run time to the provision service exposed by the Infrastructure Utility Plane and referenced in the descriptor. The form of these attributes depends on the specific implementation of the provision service invoked. The DPDS does not enforce it. TODO mettere immagine","title":"Data Product Descriptor"},{"location":"concepts/data-product-descriptor/#data-product-descriptor","text":"It's the document that serve as an entry to all the information about a data product , including its fully qualified name, owner, domain, version, interface components and internal components . It is used to share a complete view of the data product between consumers and the underlying DataOps platform throughout all its lifecycle. The objective of DPDS is to provide a standard to define the structure and content of this document.","title":"Data Product Descriptor"},{"location":"concepts/data-product-descriptor/#interface-components","text":"The interfaces exposed to external agents by a data product . These interfaces are grouped by functional role in entities named port . Each port exposes a service or set of correlated services. These are the five types of port supported by the DPSD: Input port(s): an input port describes a set of services exposed by a data product to collect its source data and makes it available for further internal transformation. An input port can receive data from one ore more upstream sources in a push (i.e. asynchronous subscription) or pop mode (i.e. synchronous query). Each data product may have one or more input ports. Output port(s): an output port describes a set of services exposed by a data product to share the generated data in a way that can be understood and trusted. Each data product may have one or more output ports. Discovery port(s): a discovery port describes a set of services exposed by a data product to provide information about its static role in the overall architecture like purpose, structure, location, etc.. Each data product may have one or multiple discovery ports. Observability port(s): an observability port describes a set of services exposed by a data product to provide information about its dynamic behaviour in the overall architecture like logs, traces, audit trails, metrics, etc.. Each data product may have one or more observability ports. Control port(s): a control port describes a set of services exposed by a data product to configure local policies or perform highly privileged governance operations. Each data product may have one or more control ports.","title":"Interface Components"},{"location":"concepts/data-product-descriptor/#internal-components","text":"","title":"Internal Components"},{"location":"concepts/data-product-descriptor/#application-components","text":"The components of a data product that implement the services exposed through its ports (i.e. pipelines, microservices, etc..). In DPDS an application component is mainly described through parametrized templates that formally define how to build and deploy the specific application component (i.e. pipeline as code ). In partircular there is one template and configurations attribute pair that describe the application build pipeline and one that describe the application deployment pipeline. These two pairs of attributes should respectvelly be passed by the Data Product Experience Plane to the proper implementation of build service and deploymet service exposed by the Infrastructure Utility Plane . The template attributes contain the definition of the pipeline that can be executed in order to build or deploy the application. The configurations attributes contain the parameters that should be passed at execution time to the build or deployment service. The form of template and configuration attributes depends on the target build or deployment service implementation exposed by the Infrastructure Utility Plane and referenced in the descriptor. The DPDS does not enforce any specific format. NOTE: TODO mettere immagine","title":"Application Components"},{"location":"concepts/data-product-descriptor/#infrastructural-components","text":"The components of a data product related to the infrastructural resources (i.e. storage, compute, etc..) used to run its application components. In DPDS an infrastructural component is mainly described through a parametrized template that formally define how to provision the specific infrastructural component (i.e. infrastructure as code). In partircular there is one template attribute that define how to provision the component and one configurations attribute that contains the parameters that should be passed at run time to the provision service exposed by the Infrastructure Utility Plane and referenced in the descriptor. The form of these attributes depends on the specific implementation of the provision service invoked. The DPDS does not enforce it. TODO mettere immagine","title":"Infrastructural Components"},{"location":"concepts/data-product/","text":"Data Product \u2693\ufe0e It's the smallest unit that can be independently deployed and managed in a data architecture (i.e. architectural quantum). It is composed by all the structural components that it requires to do its function: the metadata, the data, the code, the policies that govern the data and its dependencies to infrastructure. Each data product has a clear identifier, a version number and an owner. Aside these general informations a data product is composed by external interfaces (i.e. interface components ) and internal resources (i.e. internal components ). Interface components are public and are used by external agents to access services exposed by the data product. Internal components are private and are used by the underlyng dataops platform to deploy and operate the data product container . Data product's general informations, interface components and internal components are all described in the data product descriptor document whose structure and content is defined by the DPDS.","title":"Data Product"},{"location":"concepts/data-product/#data-product","text":"It's the smallest unit that can be independently deployed and managed in a data architecture (i.e. architectural quantum). It is composed by all the structural components that it requires to do its function: the metadata, the data, the code, the policies that govern the data and its dependencies to infrastructure. Each data product has a clear identifier, a version number and an owner. Aside these general informations a data product is composed by external interfaces (i.e. interface components ) and internal resources (i.e. internal components ). Interface components are public and are used by external agents to access services exposed by the data product. Internal components are private and are used by the underlyng dataops platform to deploy and operate the data product container . Data product's general informations, interface components and internal components are all described in the data product descriptor document whose structure and content is defined by the DPDS.","title":"Data Product"},{"location":"concepts/meshops-platform/","text":"DataMeshOps Platform \u2693\ufe0e It's the underlying self serve and domain agnostic platform that provides services to data product's teams and helps the federeted governance team to translate global policies into computational policies. In the DPDS it is referred as the DataMeshOps platform or also just the platform . It is usually devided in three main planes that group functionalites with the same overall intent. Each plane is briefly described in the following sessions because it is possible to find in the DPDS specific references to these planes. Note The specification was originally created to formalize the structure and content of a data product descriptor documents passed into a DataOps platform implemented by Quantyca for its internal projects. When the specification has been relased as an open standard it has been reviewd from inside out in order to remove any dependencies with the Quantyca 's platform. Moreover the specification has been redesigned in order to allow the creation of data product descriptor documents that can be used as a standard way to exchange informations about data products beetween all the interested parties and not only between the data product's team and the platform. Data Product Experience Plane \u2693\ufe0e It's the platform plane that have the responsability to provide the services that using the data product descriptor as input are able to build, deploy and operate a data product container . Infrastructure Utility Plane \u2693\ufe0e It's the platform plane that have the responsability to provide the services to access the underlying infrastructural resources. The interface of the services exposed by the infrastructure utility plane should be standardized as much as possible in order to decouple their consumers (i.e. the services of the data product experience plane from the actual implementation. Thanks to this decoupling it is possible to: Keep other platform planes indipendent from the underlying technology and so making them reusable in different technological environments Design the standard API of the services exposed by the infrastructure utility plane hiding all the uneccessary uderlying tecnological complexity change the implementation of the services exposed by the infrastructure utility plane without impacting the other planes Data Mesh Experience Plane \u2693\ufe0e It's the platform plane that have the responsability to provide the services to search, evaluate and query available data products. Data Product Container \u2693\ufe0e It's the boudle of all resources provisioned, deployed and operated in a specific runtime environment (ex. dev, qa, prod) associated to a specific data product . It can be viewed as a running instance of the data product described by the data product descriptor . For each descriptor multiple container insatnces can exist, usualy there could be one active instance for each runtime environments and data product's major version. In other word cannot exist multiple instance associated to a major version of a data product running in the same environment. It is possible anyway to have different version of the same data product running together in the same environment. It's a responsability of the underlyng DataMeshOps platform to interpret the data product descriptor and properly deploy and operate the related data product containers. The DPDS is designed to guarantee that all required information needed to deploy a data product container are available in the data product descriptor . It's not in the scope of the specification to define how the DataMeshOps platform should deploy and manage data product containers.","title":"DataMeshOps Platform"},{"location":"concepts/meshops-platform/#datameshops-platform","text":"It's the underlying self serve and domain agnostic platform that provides services to data product's teams and helps the federeted governance team to translate global policies into computational policies. In the DPDS it is referred as the DataMeshOps platform or also just the platform . It is usually devided in three main planes that group functionalites with the same overall intent. Each plane is briefly described in the following sessions because it is possible to find in the DPDS specific references to these planes. Note The specification was originally created to formalize the structure and content of a data product descriptor documents passed into a DataOps platform implemented by Quantyca for its internal projects. When the specification has been relased as an open standard it has been reviewd from inside out in order to remove any dependencies with the Quantyca 's platform. Moreover the specification has been redesigned in order to allow the creation of data product descriptor documents that can be used as a standard way to exchange informations about data products beetween all the interested parties and not only between the data product's team and the platform.","title":"DataMeshOps Platform"},{"location":"concepts/meshops-platform/#data-product-experience-plane","text":"It's the platform plane that have the responsability to provide the services that using the data product descriptor as input are able to build, deploy and operate a data product container .","title":"Data Product Experience Plane"},{"location":"concepts/meshops-platform/#infrastructure-utility-plane","text":"It's the platform plane that have the responsability to provide the services to access the underlying infrastructural resources. The interface of the services exposed by the infrastructure utility plane should be standardized as much as possible in order to decouple their consumers (i.e. the services of the data product experience plane from the actual implementation. Thanks to this decoupling it is possible to: Keep other platform planes indipendent from the underlying technology and so making them reusable in different technological environments Design the standard API of the services exposed by the infrastructure utility plane hiding all the uneccessary uderlying tecnological complexity change the implementation of the services exposed by the infrastructure utility plane without impacting the other planes","title":"Infrastructure Utility Plane"},{"location":"concepts/meshops-platform/#data-mesh-experience-plane","text":"It's the platform plane that have the responsability to provide the services to search, evaluate and query available data products.","title":"Data Mesh Experience Plane"},{"location":"concepts/meshops-platform/#data-product-container","text":"It's the boudle of all resources provisioned, deployed and operated in a specific runtime environment (ex. dev, qa, prod) associated to a specific data product . It can be viewed as a running instance of the data product described by the data product descriptor . For each descriptor multiple container insatnces can exist, usualy there could be one active instance for each runtime environments and data product's major version. In other word cannot exist multiple instance associated to a major version of a data product running in the same environment. It is possible anyway to have different version of the same data product running together in the same environment. It's a responsability of the underlyng DataMeshOps platform to interpret the data product descriptor and properly deploy and operate the related data product containers. The DPDS is designed to guarantee that all required information needed to deploy a data product container are available in the data product descriptor . It's not in the scope of the specification to define how the DataMeshOps platform should deploy and manage data product containers.","title":"Data Product Container"},{"location":"datamesh/","text":"Data Mesh Refereces \u2693\ufe0e Category A Link 1 Link 2 Category B Link 1 Link 2 Link 3","title":"Data Mesh Refereces"},{"location":"datamesh/#data-mesh-refereces","text":"Category A Link 1 Link 2 Category B Link 1 Link 2 Link 3","title":"Data Mesh Refereces"},{"location":"howto/","text":"HowTo(s) \u2693\ufe0e TODO","title":"HowTo(s) Intro"},{"location":"howto/#howtos","text":"TODO","title":"HowTo(s)"},{"location":"howto/build-schema-doc/","text":"How to build schema doc \u2693\ufe0e TODO","title":"How to build schema doc"},{"location":"howto/build-schema-doc/#how-to-build-schema-doc","text":"TODO","title":"How to build schema doc"},{"location":"howto/build-site-doc/","text":"How to build doc site \u2693\ufe0e TODO","title":"How to build site doc"},{"location":"howto/build-site-doc/#how-to-build-doc-site","text":"TODO","title":"How to build doc site"},{"location":"overview/","text":"Overview \u2693\ufe0e If you are new to the Data Product Descriptor Specification (DPDS) this is the right place to start. In the following page there is short charter of the specification to let you quickly decided if it feet with your needs. If so in the Site Map page you can find a structured index of all the documentation available on this site in order to plan your learning journey. Welcome on board!","title":"Overview Intro"},{"location":"overview/#overview","text":"If you are new to the Data Product Descriptor Specification (DPDS) this is the right place to start. In the following page there is short charter of the specification to let you quickly decided if it feet with your needs. If so in the Site Map page you can find a structured index of all the documentation available on this site in order to plan your learning journey. Welcome on board!","title":"Overview"},{"location":"overview/charter/","text":"Charter \u2693\ufe0e This page describes what the specification is about, its goals and scope. Start from here to understand if this specification feets with your needs or not before to deep dive in other parts of the documentation. Specification \u2693\ufe0e The Data Product Descriptor Specification (DPDS) is a declarative and technology independent open standard that can be used to describe a data product in all its components through a JSON or YAML document. It allows human agents (e.g. analysts, data scientists, etc..) and digital agents (e.g. other data products, BI tools, planes of the underlying mesh platform, etc..) to operate, discover and access a data product. When properly defined, external agents can understand and interact with the data product with a minimal amount of cognitive load and implementation logic. The formalization of a standard data product descriptor document through an open specification is useful to enable the implementation of an ecosystem of interoperable data mesh tools. The following is a non exhaustive list of tools that can benefit from this specification: catalogs (search, document and collaborate) design tools (create new products by composition of reusable templates) lifecycle management tools (deploy and operate) access management tools (assign/track access grants and generate client code in different languages) policies checking tools (enforce standard compliance and audit security) observability tools (monitor and detect) data lineage tools (trace data flows and perform forward/backward analysis) mesh topology analysis tools (calculate value/trust scores and detect structural problems) semantic tools (apply ontologies over mesh topology) domain specific language tool s (create a collection af interconnected data products that implement together a specific value stream) Check the External Tools page for more information about the available tools that use the DPDS. The Specifications page contains a list of pointers to all DPDS available versions. All DPDS versions also have an associated JSON Schema to validate a data product descriptor definition against the standard specification. The Schemas page contains a list of pointers to the schema of each available DPDS version. Context \u2693\ufe0e The first draft of the data product descriptor specification was created by Quantyca . Quantyca use it in its projects, togheter with a custom implementation of data product experience plan and infrastructure utility plane named Open Data Mesh Platform , to manage the data product lifecycle from creation till its retirement. The Open Data Mesh Platform sandardizes and automates all the data product operational activities. It's a DataOps lightweight platform deisgned for data mesh or, if you prefer, a DataMeshOps platform . The image below shows the high level architecture of the Open Data Mesh Platform and how it uses the descriptor to orchestrate all the key activities related to data product lifecycle management. Goals \u2693\ufe0e Quantyca decided to publicly release the DPDS as an open standard under Apache 2.0 licecne for the following reasons: Get feedbacks from data mesh community and practinioners on the proposed content and structure of the data product descriptor in order to improve it over time Foster discussion about what a data product is, what are its components and how its lifecycle should be managed Provide a reference specification that can be used as is, extended or customized by the ones that need a data product decriptor for their mesh implementation Try to gather and collaborate with the mesh community memebers that are interested in defining a base standard to describe data product on which we can then create the next generation of interoperable mesh tools. Principles \u2693\ufe0e The following principles are adopted in the design and evolution of the specification: The DPDS MUST be declarative The DPDS MUST be tech indipendent The DPDS MUST be standard agnostic The DPDS MUST be composable through templating The DPDS MUST be flexible in adoption The DPDS MUST be easily extensible In the design of the specification everytime different design options were possible, principles stated above have been followed to make the final decision. These same priciples will be also used to evolve the specification in the future versions. Status \u2693\ufe0e There is not yet a general available version of the specification. Version 1.0.0 is in DRAFT state. We plan to collect community feadbacks and contributions over the following months in order to finalize and release it in GA state. There is not yet a planned date for the release of version 1.0.0 in GA but ideally we would like to release it by the end of Q1 of 2023. Contributions \u2693\ufe0e All feedbacks and suggestion to improve the specification are more than welcomed. This is after all the reason why we open sourced it. We are also looking for people and organizations that want to join us in this venture. Mainly this is possible in two ways: helping us actively in the development and promotion of the specification making your DataMeshOps tool or platform compliant with the specification The Community page contains more information on how you can contribute to the project. Disclaimer \u2693\ufe0e Part of the specification and related documentation has been taken from the great work done by the folks at the OpenAPI Initiative and AsyncAPI Initiative . We have decided to not reinvent the wheel and inspire our work to these two specifications mainly for the following reasons: We think that the work made by OpenAPI Initiative and AsyncAPI Initiative is great :) We want to make the learning curve for the Data Product Descriptor Specification as smooth as possible, aligning its definition to the one of other two popular specifications in the software and data engineers community We think that OpenAPI and AsyncAPI are natural specifications for defining the interface of data product's ports that expose an API endpoint. This specification do not impose to use any specific standard for port's interface definition but these two are highly recommended.","title":"Charter"},{"location":"overview/charter/#charter","text":"This page describes what the specification is about, its goals and scope. Start from here to understand if this specification feets with your needs or not before to deep dive in other parts of the documentation.","title":"Charter"},{"location":"overview/charter/#specification","text":"The Data Product Descriptor Specification (DPDS) is a declarative and technology independent open standard that can be used to describe a data product in all its components through a JSON or YAML document. It allows human agents (e.g. analysts, data scientists, etc..) and digital agents (e.g. other data products, BI tools, planes of the underlying mesh platform, etc..) to operate, discover and access a data product. When properly defined, external agents can understand and interact with the data product with a minimal amount of cognitive load and implementation logic. The formalization of a standard data product descriptor document through an open specification is useful to enable the implementation of an ecosystem of interoperable data mesh tools. The following is a non exhaustive list of tools that can benefit from this specification: catalogs (search, document and collaborate) design tools (create new products by composition of reusable templates) lifecycle management tools (deploy and operate) access management tools (assign/track access grants and generate client code in different languages) policies checking tools (enforce standard compliance and audit security) observability tools (monitor and detect) data lineage tools (trace data flows and perform forward/backward analysis) mesh topology analysis tools (calculate value/trust scores and detect structural problems) semantic tools (apply ontologies over mesh topology) domain specific language tool s (create a collection af interconnected data products that implement together a specific value stream) Check the External Tools page for more information about the available tools that use the DPDS. The Specifications page contains a list of pointers to all DPDS available versions. All DPDS versions also have an associated JSON Schema to validate a data product descriptor definition against the standard specification. The Schemas page contains a list of pointers to the schema of each available DPDS version.","title":"Specification"},{"location":"overview/charter/#context","text":"The first draft of the data product descriptor specification was created by Quantyca . Quantyca use it in its projects, togheter with a custom implementation of data product experience plan and infrastructure utility plane named Open Data Mesh Platform , to manage the data product lifecycle from creation till its retirement. The Open Data Mesh Platform sandardizes and automates all the data product operational activities. It's a DataOps lightweight platform deisgned for data mesh or, if you prefer, a DataMeshOps platform . The image below shows the high level architecture of the Open Data Mesh Platform and how it uses the descriptor to orchestrate all the key activities related to data product lifecycle management.","title":"Context"},{"location":"overview/charter/#goals","text":"Quantyca decided to publicly release the DPDS as an open standard under Apache 2.0 licecne for the following reasons: Get feedbacks from data mesh community and practinioners on the proposed content and structure of the data product descriptor in order to improve it over time Foster discussion about what a data product is, what are its components and how its lifecycle should be managed Provide a reference specification that can be used as is, extended or customized by the ones that need a data product decriptor for their mesh implementation Try to gather and collaborate with the mesh community memebers that are interested in defining a base standard to describe data product on which we can then create the next generation of interoperable mesh tools.","title":"Goals"},{"location":"overview/charter/#principles","text":"The following principles are adopted in the design and evolution of the specification: The DPDS MUST be declarative The DPDS MUST be tech indipendent The DPDS MUST be standard agnostic The DPDS MUST be composable through templating The DPDS MUST be flexible in adoption The DPDS MUST be easily extensible In the design of the specification everytime different design options were possible, principles stated above have been followed to make the final decision. These same priciples will be also used to evolve the specification in the future versions.","title":"Principles"},{"location":"overview/charter/#status","text":"There is not yet a general available version of the specification. Version 1.0.0 is in DRAFT state. We plan to collect community feadbacks and contributions over the following months in order to finalize and release it in GA state. There is not yet a planned date for the release of version 1.0.0 in GA but ideally we would like to release it by the end of Q1 of 2023.","title":"Status"},{"location":"overview/charter/#contributions","text":"All feedbacks and suggestion to improve the specification are more than welcomed. This is after all the reason why we open sourced it. We are also looking for people and organizations that want to join us in this venture. Mainly this is possible in two ways: helping us actively in the development and promotion of the specification making your DataMeshOps tool or platform compliant with the specification The Community page contains more information on how you can contribute to the project.","title":"Contributions"},{"location":"overview/charter/#disclaimer","text":"Part of the specification and related documentation has been taken from the great work done by the folks at the OpenAPI Initiative and AsyncAPI Initiative . We have decided to not reinvent the wheel and inspire our work to these two specifications mainly for the following reasons: We think that the work made by OpenAPI Initiative and AsyncAPI Initiative is great :) We want to make the learning curve for the Data Product Descriptor Specification as smooth as possible, aligning its definition to the one of other two popular specifications in the software and data engineers community We think that OpenAPI and AsyncAPI are natural specifications for defining the interface of data product's ports that expose an API endpoint. This specification do not impose to use any specific standard for port's interface definition but these two are highly recommended.","title":"Disclaimer"},{"location":"overview/sitemap/","text":"Site Map \u2693\ufe0e This site contains all the available documentation related to the Data Product Descriptor Specification (DPDS). The site is orgaized as follow: Overview : This page describes what the specification is about, its goals and scope. Start from here to understand if this specification feets with your needs or not before to deep dive in other parts of the documentation. Concepts : This page describe the key concepts used in the specification and through out all the documentation. Most of them are related to data mesh paradigm . Ths page anyway is not a data mesh guide. It just positionates some data mesh concepts in the scope of this specification to avoid possible source of ambiguity. Quikstart : This pages describe the key parts of the specification in an informal and incremental way to simplify the learning process. HowTo(s) : This pages contain guides that describe how to perform specific activites related to the DPDS lifecycle management. Contributions : This page expalins the possible ways to contribute to the specification evolution. References : These pages point to external resources related to the DPDS. Specifications : This page points to html version of the DPDS. Json Schema : This page contains the documenation of the JSON Schema defied to validate data product descriptor definition compliant with the DPDS. Examples : This page contains some examples of valid data product descriptor definition together with their description. External Tools : This page contains a list of tools that use the standard devided by category. Related Standards : This page contains tahe list of other stnadard that are related with the DPDS devided by category. Data Mesh Resources : This page contains a list of resources useful to start learning about data mesh paradigm. Note All the documentation above assume a previous knowledge about data mesh paradigm. If you are new to the topic and you want to know more this documentation is not the right place. Please check the Data Mesh Resources page to find out better resources to start your data mesh study.","title":"Site Map"},{"location":"overview/sitemap/#site-map","text":"This site contains all the available documentation related to the Data Product Descriptor Specification (DPDS). The site is orgaized as follow: Overview : This page describes what the specification is about, its goals and scope. Start from here to understand if this specification feets with your needs or not before to deep dive in other parts of the documentation. Concepts : This page describe the key concepts used in the specification and through out all the documentation. Most of them are related to data mesh paradigm . Ths page anyway is not a data mesh guide. It just positionates some data mesh concepts in the scope of this specification to avoid possible source of ambiguity. Quikstart : This pages describe the key parts of the specification in an informal and incremental way to simplify the learning process. HowTo(s) : This pages contain guides that describe how to perform specific activites related to the DPDS lifecycle management. Contributions : This page expalins the possible ways to contribute to the specification evolution. References : These pages point to external resources related to the DPDS. Specifications : This page points to html version of the DPDS. Json Schema : This page contains the documenation of the JSON Schema defied to validate data product descriptor definition compliant with the DPDS. Examples : This page contains some examples of valid data product descriptor definition together with their description. External Tools : This page contains a list of tools that use the standard devided by category. Related Standards : This page contains tahe list of other stnadard that are related with the DPDS devided by category. Data Mesh Resources : This page contains a list of resources useful to start learning about data mesh paradigm. Note All the documentation above assume a previous knowledge about data mesh paradigm. If you are new to the topic and you want to know more this documentation is not the right place. Please check the Data Mesh Resources page to find out better resources to start your data mesh study.","title":"Site Map"},{"location":"quickstart/","text":"Quickstart \u2693\ufe0e The Data Product Descriptor Specification (DPDS) is the ultimate source of knowledge regarding this data product description format. However, its length is daunting to newcomers and makes it hard for experienced users to find specific bits of information. This page provides a soft landing for readers not yet familiar with DPDS and is organized by topic, simplifying browsing. The following pages introduce the syntax and structure of a data product descriptor document, its main building blocks and a minimal data product descriptor document. Afterwards, the different blocks are detailed, starting from the most common and progressing towards advanced ones. Descriptor Document Overview : JSON, YAML Minimal Descriptor Document : dataProductDescriptor and info Interface Components : interfaceComponents , promises , expectations and contracts Application Components : applicationComponents , buildService and deploymentService Infrastructural Components : infrastructuralComponents and provisioningService Reusing Descriptions : components and $ref . External Resources : todo Standard Definitions : todo Extending the specification : todo","title":"Quickstart Intro"},{"location":"quickstart/#quickstart","text":"The Data Product Descriptor Specification (DPDS) is the ultimate source of knowledge regarding this data product description format. However, its length is daunting to newcomers and makes it hard for experienced users to find specific bits of information. This page provides a soft landing for readers not yet familiar with DPDS and is organized by topic, simplifying browsing. The following pages introduce the syntax and structure of a data product descriptor document, its main building blocks and a minimal data product descriptor document. Afterwards, the different blocks are detailed, starting from the most common and progressing towards advanced ones. Descriptor Document Overview : JSON, YAML Minimal Descriptor Document : dataProductDescriptor and info Interface Components : interfaceComponents , promises , expectations and contracts Application Components : applicationComponents , buildService and deploymentService Infrastructural Components : infrastructuralComponents and provisioningService Reusing Descriptions : components and $ref . External Resources : todo Standard Definitions : todo Extending the specification : todo","title":"Quickstart"},{"location":"quickstart/application/","text":"Application Components \u2693\ufe0e The previous page showed how to define the interface of services exposed by a data product . This page explains how to define the application components that implement these services. Application Component \u2693\ufe0e Appliction components are internal components of a data product. This mean that, while the interface components are publicly available on demand to all consumers, access to application components can be restricted. All internal components of a data product are contained in the Internal Components Object , accessible through the internalComponents field in the root Data Product Descriptor Entity . Within this object the field applicationComponents contains the list of all Application Component of the data product. Fields \u2693\ufe0e An Application Component has the following two mandatory fields: fullyQualifiedName (string:fqn): This is the unique universal idetifier of the component. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:applications:{app-name} version (string:version): This is the semantic version number of the data product's application component. The version of application components have no direct impact of the version of the data product they belong to. A change in the major version of an appication component can anyway impact the version of one interface components and so indirectly the version of the data product. Other non mandatory descriptive fields like platform and applicationType are also available. Moreover the Application Component can be extended with other fields with \"x-\" prefix as needed. Example \u2693\ufe0e The following example shows three application components that respectively describe 1. an application that load data form a downstream legacy sistem (i.e. TMS ) in relatime through CDC technlogy (i.e. Debezium ). 1. a streaming application that trasform the techincal events loaded in the streaming platfrom (i.e. Confluent platform ) by the previous application in domain events. 1. a streaming appplication that use the domain events generated by the previous application to update the trip status in a downstream table stored in a postgres db. All three applications are deployed in eu-south-1 region of AWS Cloud . { \"applicationComponents\" : [ { \"fullyQualifiedName\" : \"urn:dpds:com.company-xyz:dataproducts:tripExecution:1:applications:cdcIngestion\" , \"version\" : \"1.0.1\" , \"description\" : \"The app that offload the Trip aggregate from TMS using CDC\" , \"platform\" : \"aws:eu-south-1:debezium\" , \"applicationType\" : \"stream-sourcing\" }, { \"fullyQualifiedName\" : \"urn:dpds:com.company-xyz:dataproducts:tripExecution:1:applications:eventProcessor\" , \"version\" : \"1.1.0\" , \"description\" : \"The app that transform tecnical events in domain events\" , \"platform\" : \"aws:eu-south-1:confluent\" , \"applicationType\" : \"stream-transformation\" }, { \"fullyQualifiedName\" : \"urn:dpds:com.company-xyz:dataproducts:tripExecution:1:applications:dbSinkConnector\" , \"version\" : \"1.1.3\" , \"description\" : \"The app that store the updated state of a Trip in the target postgres db\" , \"platform\" : \"aws:eu-south-1:confluent\" , \"applicationType\" : \"stream-transformation\" } ] } The information provided so far are useful to track the application assets related to a specific data product. There are not anyway sufficient informtion to allow an external agent to build and deploy the application autonomously. To this end in the Application Component there are the buildService and deploymentService fileds that are described in much details in the next sections. Build Service Object \u2693\ufe0e The Build Info Object contains the informations required to build an application component. DPDS uses integration pipelines as code to guarantee the possibility to automatize the build process in a riproducible way. Anyway to mantain technological indipendence the DPDS do not enforce the usage of any specific CICD tool. Fileds \u2693\ufe0e A Build Info Object has the following three mandatory fields: service ( string:name or External Resource Object ): This is the logical name or the actual endpoint of the service to call in order to build the application component. If the logical name (ex. jenkins , aws-pipelines , azure-devops , ecc...) is used as field value the actual endpoint value resulution is demanded to the data product experience plane of the underlyng platform. template ( object or External Resource Object ): This is the definition of the pipeline to execute in order to build the application. It is passed as is to the build service implementation specified in the service field. configurations ( object or External Resource Object ): This is the map of all configuration properties that must be used by the build service at build time. It is passed as is to the build service implementation specified in the service field. Example \u2693\ufe0e The following example shows an appliction that could be built using a jankins backed build service . The jenkinsfile that contains the description of the pipeline is available on an external bitbucket repository . The only configuration parameter passed in to the build service at runtime is the target stage. { \"service\" : \"jenkins\" , \"template\" : { \"mediaType\" : \"text/jenkinsfile\" , \"$href\" : \"https://bitbucket.org/company-xyz/trip-execution-app-sourcing/src/master/jenkinsfile\" }, \"configurations\" : { \"TARGET_STAGE\" : \"BUILD\" , } } Deployment Service Object \u2693\ufe0e The Deployment Info Object contains the informations required to deploy an application component. DPDS uses integration pipelines as code to guarantee the possibility to automatize the deployment process in a riproducible way. Anyway to mantain technological indipendence the DPDS do not enforce the usage of any specific CICD tool. Fileds \u2693\ufe0e A Deployment Info Object has the following three mandatory fields: service ( string:name or External Resource Object ): This is the logical name or the actual endpoint of the service to call in order to deploy the application component. If the logical name (ex. jenkins , aws-pipelines , azure-devops , ecc...) is used as field value the actual endpoint value resulution is demanded to the data product experience plane of the underlyng platform. template ( object or External Resource Object ): This is the definition of the pipeline to execute in order to deploy the application. It is passed as is to the deployment service implementation specified in the service field. configurations ( object or External Resource Object ): This is the map of all configuration properties that must be used by the build service at deployment time. It is passed as is to the deployment service implementation specified in the service field. Example \u2693\ufe0e The following example shows an appliction that could be deployed using a jankins backed deployment service . The jenkinsfile that contains the description of the pipeline is available on an external bitbucket repository . The only configuration parameters passed in to the deployment service at runtime are the initial stage stage and the end state that identify the portion of the pipeline that must be executed. { \"service\" : { \"mediaType\" : \"application\" , \"$href\" : \"https://jenkins.company-xyz.com/api/v1/planes/utility/integration-services/builds\" }, \"template\" : { \"mediaType\" : \"text/jenkinsfile\" , \"$href\" : \"https://bitbucket.org/company-xyz/trip-execution-app-sourcing/src/master/jenkinsfile\" }, \"configurations\" : { \"START_STAGE\" : \"BUILD\" , \"TARGET_STAGE\" : \"DEPLOY\" , } } Summary \u2693\ufe0e This page has shown that: a data product is composed not only by its public interface but also by internal componnets applications that implement the exposed interfaces are internal components described through an Application Component . Application Component contains general information related to the specific application but also all the required information to build and deploy the application in an automatic and reproducible way. the DPDS uses pipeline as code to define how to build and deploy an application but do not enforce the use of any particular CICD tool, preserving in this way its technology independence . The next page describes the contents of the infrastructuralComponents field used to provide all the required information to provision the infastructure required by application components that implement the services exposed by the product through its ports.","title":"Application Components"},{"location":"quickstart/application/#application-components","text":"The previous page showed how to define the interface of services exposed by a data product . This page explains how to define the application components that implement these services.","title":"Application Components"},{"location":"quickstart/application/#application-component","text":"Appliction components are internal components of a data product. This mean that, while the interface components are publicly available on demand to all consumers, access to application components can be restricted. All internal components of a data product are contained in the Internal Components Object , accessible through the internalComponents field in the root Data Product Descriptor Entity . Within this object the field applicationComponents contains the list of all Application Component of the data product.","title":"Application Component"},{"location":"quickstart/application/#fields","text":"An Application Component has the following two mandatory fields: fullyQualifiedName (string:fqn): This is the unique universal idetifier of the component. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:applications:{app-name} version (string:version): This is the semantic version number of the data product's application component. The version of application components have no direct impact of the version of the data product they belong to. A change in the major version of an appication component can anyway impact the version of one interface components and so indirectly the version of the data product. Other non mandatory descriptive fields like platform and applicationType are also available. Moreover the Application Component can be extended with other fields with \"x-\" prefix as needed.","title":"Fields"},{"location":"quickstart/application/#example","text":"The following example shows three application components that respectively describe 1. an application that load data form a downstream legacy sistem (i.e. TMS ) in relatime through CDC technlogy (i.e. Debezium ). 1. a streaming application that trasform the techincal events loaded in the streaming platfrom (i.e. Confluent platform ) by the previous application in domain events. 1. a streaming appplication that use the domain events generated by the previous application to update the trip status in a downstream table stored in a postgres db. All three applications are deployed in eu-south-1 region of AWS Cloud . { \"applicationComponents\" : [ { \"fullyQualifiedName\" : \"urn:dpds:com.company-xyz:dataproducts:tripExecution:1:applications:cdcIngestion\" , \"version\" : \"1.0.1\" , \"description\" : \"The app that offload the Trip aggregate from TMS using CDC\" , \"platform\" : \"aws:eu-south-1:debezium\" , \"applicationType\" : \"stream-sourcing\" }, { \"fullyQualifiedName\" : \"urn:dpds:com.company-xyz:dataproducts:tripExecution:1:applications:eventProcessor\" , \"version\" : \"1.1.0\" , \"description\" : \"The app that transform tecnical events in domain events\" , \"platform\" : \"aws:eu-south-1:confluent\" , \"applicationType\" : \"stream-transformation\" }, { \"fullyQualifiedName\" : \"urn:dpds:com.company-xyz:dataproducts:tripExecution:1:applications:dbSinkConnector\" , \"version\" : \"1.1.3\" , \"description\" : \"The app that store the updated state of a Trip in the target postgres db\" , \"platform\" : \"aws:eu-south-1:confluent\" , \"applicationType\" : \"stream-transformation\" } ] } The information provided so far are useful to track the application assets related to a specific data product. There are not anyway sufficient informtion to allow an external agent to build and deploy the application autonomously. To this end in the Application Component there are the buildService and deploymentService fileds that are described in much details in the next sections.","title":"Example"},{"location":"quickstart/application/#build-service-object","text":"The Build Info Object contains the informations required to build an application component. DPDS uses integration pipelines as code to guarantee the possibility to automatize the build process in a riproducible way. Anyway to mantain technological indipendence the DPDS do not enforce the usage of any specific CICD tool.","title":"Build Service Object"},{"location":"quickstart/application/#fileds","text":"A Build Info Object has the following three mandatory fields: service ( string:name or External Resource Object ): This is the logical name or the actual endpoint of the service to call in order to build the application component. If the logical name (ex. jenkins , aws-pipelines , azure-devops , ecc...) is used as field value the actual endpoint value resulution is demanded to the data product experience plane of the underlyng platform. template ( object or External Resource Object ): This is the definition of the pipeline to execute in order to build the application. It is passed as is to the build service implementation specified in the service field. configurations ( object or External Resource Object ): This is the map of all configuration properties that must be used by the build service at build time. It is passed as is to the build service implementation specified in the service field.","title":"Fileds"},{"location":"quickstart/application/#example_1","text":"The following example shows an appliction that could be built using a jankins backed build service . The jenkinsfile that contains the description of the pipeline is available on an external bitbucket repository . The only configuration parameter passed in to the build service at runtime is the target stage. { \"service\" : \"jenkins\" , \"template\" : { \"mediaType\" : \"text/jenkinsfile\" , \"$href\" : \"https://bitbucket.org/company-xyz/trip-execution-app-sourcing/src/master/jenkinsfile\" }, \"configurations\" : { \"TARGET_STAGE\" : \"BUILD\" , } }","title":"Example"},{"location":"quickstart/application/#deployment-service-object","text":"The Deployment Info Object contains the informations required to deploy an application component. DPDS uses integration pipelines as code to guarantee the possibility to automatize the deployment process in a riproducible way. Anyway to mantain technological indipendence the DPDS do not enforce the usage of any specific CICD tool.","title":"Deployment Service Object"},{"location":"quickstart/application/#fileds_1","text":"A Deployment Info Object has the following three mandatory fields: service ( string:name or External Resource Object ): This is the logical name or the actual endpoint of the service to call in order to deploy the application component. If the logical name (ex. jenkins , aws-pipelines , azure-devops , ecc...) is used as field value the actual endpoint value resulution is demanded to the data product experience plane of the underlyng platform. template ( object or External Resource Object ): This is the definition of the pipeline to execute in order to deploy the application. It is passed as is to the deployment service implementation specified in the service field. configurations ( object or External Resource Object ): This is the map of all configuration properties that must be used by the build service at deployment time. It is passed as is to the deployment service implementation specified in the service field.","title":"Fileds"},{"location":"quickstart/application/#example_2","text":"The following example shows an appliction that could be deployed using a jankins backed deployment service . The jenkinsfile that contains the description of the pipeline is available on an external bitbucket repository . The only configuration parameters passed in to the deployment service at runtime are the initial stage stage and the end state that identify the portion of the pipeline that must be executed. { \"service\" : { \"mediaType\" : \"application\" , \"$href\" : \"https://jenkins.company-xyz.com/api/v1/planes/utility/integration-services/builds\" }, \"template\" : { \"mediaType\" : \"text/jenkinsfile\" , \"$href\" : \"https://bitbucket.org/company-xyz/trip-execution-app-sourcing/src/master/jenkinsfile\" }, \"configurations\" : { \"START_STAGE\" : \"BUILD\" , \"TARGET_STAGE\" : \"DEPLOY\" , } }","title":"Example"},{"location":"quickstart/application/#summary","text":"This page has shown that: a data product is composed not only by its public interface but also by internal componnets applications that implement the exposed interfaces are internal components described through an Application Component . Application Component contains general information related to the specific application but also all the required information to build and deploy the application in an automatic and reproducible way. the DPDS uses pipeline as code to define how to build and deploy an application but do not enforce the use of any particular CICD tool, preserving in this way its technology independence . The next page describes the contents of the infrastructuralComponents field used to provide all the required information to provision the infastructure required by application components that implement the services exposed by the product through its ports.","title":"Summary"},{"location":"quickstart/components/","text":"Reusing Descriptions \u2693\ufe0e As is often the case, the example built through the previous pages has grown too large to be easily manageable. This page introduces a mechanism to remove redundancy from an data product descriptor document by reusing portions of it. Components Object \u2693\ufe0e The Components Object , accessible through the components field in the root Data Product Descriptor Entity , contains definitions for objects to be reused in other parts of the document. TODO add image Most objects in an data product descriptor document can be replaced by a reference to a component , drastically reducing the document\u2019s size and maintenance cost (just like methods do in programming languages). Not all objects can be referenced, though, only those listed as fields of the Components Object like outputPorts , applicationComponents and infrastructuralComponents to name a few. Each field in the Components Object is a map pairing component names with objects to be reused. The type of these objects must match the parent field, e.g. objects in the outputPorts map must be Output Port Components . { \"components\" : { \"applicationComponents\" : { \"cdcIngestion\" : { \"fullyQualifiedName\" : \"urn:dpds:com.company-xyz:dataproducts:tripExecution:1:applications:cdcIngestion\" , \"version\" : \"1.0.1\" , \"description\" : \"The app that offload the Trip aggregate from TMS using CDC\" , \"platform\" : \"aws:eu-south-1:debezium\" , \"applicationType\" : \"stream-sourcing\" } }, \"infrastructuralComponents\" : { \"eventStore\" : { \"fullyQualifiedName\" : \"urn:dpds:com.company-xyz:dataproducts:tripExecution:1:infrastructure:eventStore\" , \"version\" : \"1.0.1\" , \"description\" : \"The kafka topics topology required to store technical events offloaded from TMS by the CDC and the domain events generetaed by eventProcessor application\" , \"platform\" : \"aws:eu-south-1:confluent\" , \"infrastructureType\" : \"storage-resource\" } } } } The above example defines two components: cdcIngestion is an application component, usable wherever a Application Component is expected. eventStore is an infrastructural component, usable wherever a Infrastructural Component is expected. The next section explains how to reference these components. Reference Object \u2693\ufe0e Any data product descriptor object of the types supported by the Components Object can be replaced by a Reference Object pointing to a component. Reference Object are actually JSON References : they contain a field named $ref and its string value is a URI pointing to the referenced object: { \"internalComponents\" : { \"applicationComponents\" : { \"$ref\" : \"#/components/applicationComponents/cdcIngestion\" }, \"infrastructuralComponents\" : { \"$ref\" : \"#/components/infrastructuralComponents/eventStore\" } } } Note how all references point to different fragments inside the same document (the one being processed). The Reference Object can be used also to point to external documents or event to fragment inside external documents. { \"interfaceComponents\" : { \"outputPorts\" : [ { \"$ref\" : \"https://bitbucket.org/company-xyz/trip-execution/src/master/ports/output-ports.json#/tripEvents\" }, { \"$ref\" : \"https://bitbucket.org/company-xyz/trip-execution/src/master/ports/output-ports.json#/tripStatus\" } ] } } Summary \u2693\ufe0e Whenever the same piece of JSON or YAML is repeated in an data product descriptor document, it is probably worth converting it into a component and referencing it everywhere else. Furthermore, Reference Object allow splitting a document into several files to keep them organized and their individual size manageable. This page has shown that: Reusable Reference Object can be defined by using the components field of the root Data Product Descriptor Entity . Components can be referenced from any place where an object of the same type is expected using $ref . References are actually URIs so they are very flexible. The next page explains how to include external resources in a data product descriptor document.","title":"Reusing Descriptions"},{"location":"quickstart/components/#reusing-descriptions","text":"As is often the case, the example built through the previous pages has grown too large to be easily manageable. This page introduces a mechanism to remove redundancy from an data product descriptor document by reusing portions of it.","title":"Reusing Descriptions"},{"location":"quickstart/components/#components-object","text":"The Components Object , accessible through the components field in the root Data Product Descriptor Entity , contains definitions for objects to be reused in other parts of the document. TODO add image Most objects in an data product descriptor document can be replaced by a reference to a component , drastically reducing the document\u2019s size and maintenance cost (just like methods do in programming languages). Not all objects can be referenced, though, only those listed as fields of the Components Object like outputPorts , applicationComponents and infrastructuralComponents to name a few. Each field in the Components Object is a map pairing component names with objects to be reused. The type of these objects must match the parent field, e.g. objects in the outputPorts map must be Output Port Components . { \"components\" : { \"applicationComponents\" : { \"cdcIngestion\" : { \"fullyQualifiedName\" : \"urn:dpds:com.company-xyz:dataproducts:tripExecution:1:applications:cdcIngestion\" , \"version\" : \"1.0.1\" , \"description\" : \"The app that offload the Trip aggregate from TMS using CDC\" , \"platform\" : \"aws:eu-south-1:debezium\" , \"applicationType\" : \"stream-sourcing\" } }, \"infrastructuralComponents\" : { \"eventStore\" : { \"fullyQualifiedName\" : \"urn:dpds:com.company-xyz:dataproducts:tripExecution:1:infrastructure:eventStore\" , \"version\" : \"1.0.1\" , \"description\" : \"The kafka topics topology required to store technical events offloaded from TMS by the CDC and the domain events generetaed by eventProcessor application\" , \"platform\" : \"aws:eu-south-1:confluent\" , \"infrastructureType\" : \"storage-resource\" } } } } The above example defines two components: cdcIngestion is an application component, usable wherever a Application Component is expected. eventStore is an infrastructural component, usable wherever a Infrastructural Component is expected. The next section explains how to reference these components.","title":"Components Object"},{"location":"quickstart/components/#reference-object","text":"Any data product descriptor object of the types supported by the Components Object can be replaced by a Reference Object pointing to a component. Reference Object are actually JSON References : they contain a field named $ref and its string value is a URI pointing to the referenced object: { \"internalComponents\" : { \"applicationComponents\" : { \"$ref\" : \"#/components/applicationComponents/cdcIngestion\" }, \"infrastructuralComponents\" : { \"$ref\" : \"#/components/infrastructuralComponents/eventStore\" } } } Note how all references point to different fragments inside the same document (the one being processed). The Reference Object can be used also to point to external documents or event to fragment inside external documents. { \"interfaceComponents\" : { \"outputPorts\" : [ { \"$ref\" : \"https://bitbucket.org/company-xyz/trip-execution/src/master/ports/output-ports.json#/tripEvents\" }, { \"$ref\" : \"https://bitbucket.org/company-xyz/trip-execution/src/master/ports/output-ports.json#/tripStatus\" } ] } }","title":"Reference Object"},{"location":"quickstart/components/#summary","text":"Whenever the same piece of JSON or YAML is repeated in an data product descriptor document, it is probably worth converting it into a component and referencing it everywhere else. Furthermore, Reference Object allow splitting a document into several files to keep them organized and their individual size manageable. This page has shown that: Reusable Reference Object can be defined by using the components field of the root Data Product Descriptor Entity . Components can be referenced from any place where an object of the same type is expected using $ref . References are actually URIs so they are very flexible. The next page explains how to include external resources in a data product descriptor document.","title":"Summary"},{"location":"quickstart/info/","text":"Minimal Descriptor Document \u2693\ufe0e The previous page showed the overall syntax and structure of a data product descriptor document. The data product descriptor document structure is long and complex so this page just describes the minimal set of fields it must contain, while following pages give more details about specific objects. Data Product Descriptor Entity \u2693\ufe0e The root object in any data product descriptor document is the Data Product Descriptor Entity . The Info Object contains tha genarl info related to the data product while the Interface Components Object contains all its public interfaces. Fields \u2693\ufe0e Only three fields of the Data Product Descriptor Entity are mandatory: dataProductDescriptor , info and interfaceComponents.outputPorts . dataProductDescriptor ( string:version ): This indicates the version of the DADS this document is using, e.g. \u201c1.0.0\u201d. Using this field tools can check that the document correctly adheres to the specification. info ( Info Object ): this provides general information about the data product (like its description and contact information) but the only mandatory fields are fullyQualifiedName , name , version , domain and owner . fullyQualifiedName ( string:fqn ): This is the unique universal idetifier of the data product. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version} . It's RECOMMENDED to use as mesh-namespace your company's domain name in reverse dot notation (ex. com.mycompany ) in order to ensure that the fullyQualifiedName is unique universal idetifier as REQUIRED. version ( string:version ): this is the semantic version number of the data product (not to be confused with the dataProductDescriptor version above). domain ( string ): This is the domain to which the data product belongs to. owner ( Owner Object ): This is a collection of information related to the data product's owner. The only mandatory field is the id of the owner, usually his or her corporate mail address. interfaceComponents ( Interface Components Object ): This is a collection of all ports exposed by the data product (i.e. input, output, ecc...). The only mandatory field is outputPorts that contais the list of all output ports of the data product. outputPorts ( array of Output Port Component ): These are the output ports exposed by the data product. Example \u2693\ufe0e The following example shows a minimal data product descriptor document: { \"dataProductDescriptor\" : \"1.0.0\" , \"info\" : { \"fullyQualifiedName\" : \"urn:dpds:com.company-xyz:dataproducts:tripExecution:1\" , \"version\" : \"1.2.3\" , \"domain\" : \"Transport Management\" , \"owner\" : { \"id\" : \"john.doe@company-xyz.com\" , \"name\" : \"John Doe\" }, \"interfaceComponents\" : { \"outputPorts\" : [] } } } This data product is not very useful because it defines no output ports (it does not expose any data). The next page remedies that. Summary \u2693\ufe0e This page has shown that: Every data product descriptor document must contain a root object with at least the fields dataProductDescriptor , info and interfaceComponents.outputPorts . The next page describes the contents of the interfaceComponents field so ports can be added to the above minimal snippet.","title":"Minimal Descriptor Document"},{"location":"quickstart/info/#minimal-descriptor-document","text":"The previous page showed the overall syntax and structure of a data product descriptor document. The data product descriptor document structure is long and complex so this page just describes the minimal set of fields it must contain, while following pages give more details about specific objects.","title":"Minimal Descriptor Document"},{"location":"quickstart/info/#data-product-descriptor-entity","text":"The root object in any data product descriptor document is the Data Product Descriptor Entity . The Info Object contains tha genarl info related to the data product while the Interface Components Object contains all its public interfaces.","title":"Data Product Descriptor Entity"},{"location":"quickstart/info/#fields","text":"Only three fields of the Data Product Descriptor Entity are mandatory: dataProductDescriptor , info and interfaceComponents.outputPorts . dataProductDescriptor ( string:version ): This indicates the version of the DADS this document is using, e.g. \u201c1.0.0\u201d. Using this field tools can check that the document correctly adheres to the specification. info ( Info Object ): this provides general information about the data product (like its description and contact information) but the only mandatory fields are fullyQualifiedName , name , version , domain and owner . fullyQualifiedName ( string:fqn ): This is the unique universal idetifier of the data product. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version} . It's RECOMMENDED to use as mesh-namespace your company's domain name in reverse dot notation (ex. com.mycompany ) in order to ensure that the fullyQualifiedName is unique universal idetifier as REQUIRED. version ( string:version ): this is the semantic version number of the data product (not to be confused with the dataProductDescriptor version above). domain ( string ): This is the domain to which the data product belongs to. owner ( Owner Object ): This is a collection of information related to the data product's owner. The only mandatory field is the id of the owner, usually his or her corporate mail address. interfaceComponents ( Interface Components Object ): This is a collection of all ports exposed by the data product (i.e. input, output, ecc...). The only mandatory field is outputPorts that contais the list of all output ports of the data product. outputPorts ( array of Output Port Component ): These are the output ports exposed by the data product.","title":"Fields"},{"location":"quickstart/info/#example","text":"The following example shows a minimal data product descriptor document: { \"dataProductDescriptor\" : \"1.0.0\" , \"info\" : { \"fullyQualifiedName\" : \"urn:dpds:com.company-xyz:dataproducts:tripExecution:1\" , \"version\" : \"1.2.3\" , \"domain\" : \"Transport Management\" , \"owner\" : { \"id\" : \"john.doe@company-xyz.com\" , \"name\" : \"John Doe\" }, \"interfaceComponents\" : { \"outputPorts\" : [] } } } This data product is not very useful because it defines no output ports (it does not expose any data). The next page remedies that.","title":"Example"},{"location":"quickstart/info/#summary","text":"This page has shown that: Every data product descriptor document must contain a root object with at least the fields dataProductDescriptor , info and interfaceComponents.outputPorts . The next page describes the contents of the interfaceComponents field so ports can be added to the above minimal snippet.","title":"Summary"},{"location":"quickstart/infrastructure/","text":"Infrastructural Components \u2693\ufe0e The previous page showed how to define the application components that implement the services exposed by a data product through its ports . This page explains how to define the infrastructural components required to execute these applications. Infrastructural Component Object \u2693\ufe0e Infrastructural components are internal components of a data product. This mean that, while the interface components are publicly available on demand to all consumers, access to infrastructural components can be restricted. All internal components of a data product are contained in the Internal Components Object , accessible through the internalComponents field in the root Data Product Descriptor Entity . Within this object the field infrastructuralComponents contains the list of all Infrastructural Component of the data product. Fields \u2693\ufe0e An Infrastructural Component has the following two mandatory fields: fullyQualifiedName (string:fqn): This is the unique universal idetifier of the component. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:infrastructure:{infra-name}. version (string:version): This is the semantic version number of the data product's infrastructural component. The version of infrastructural components have no direct impact of the version of the data product they belong to. A change in the major version of an infrastructural component can anyway impact the version of one interface components and so indirectly the version of the data product. Other non mandatory descriptive fields like platform and infrastructureType are also available. Moreover the Infrastructural Component can be extended with other fields with \"x-\" prefix as needed. Example \u2693\ufe0e The following example shows two infrastructural components that respectively describe The topology of kafka topics required to store technical events generated by the cdcIngestion application while offloading data from the TMS source . domain events generated by eventProcessor application as composition of technical events that belong to the same transaction intercepted by cdcIngestion on the TMS source . The schema and and tables required by dbSinkConnector application to materialize from streamed domain events the updated state of each Trip . { \"infrastructuralComponents\" : [ { \"fullyQualifiedName\" : \"urn:dpds:com.company-xyz:dataproducts:tripExecution:1:infrastructure:eventStore\" , \"version\" : \"1.0.1\" , \"description\" : \"The kafka topics topology required to store technical events offloaded from TMS by the CDC and the domain events generetaed by eventProcessor application\" , \"platform\" : \"aws:eu-south-1:confluent\" , \"infrastructureType\" : \"storage-resource\" }, { \"fullyQualifiedName\" : \"urn:dpds:com.company-xyz:dataproducts:tripExecution:1:infrastructure:stateStore\" , \"version\" : \"1.0.0\" , \"description\" : \"The database used by dbSinkConnector application to store the Trip updated state\" , \"platform\" : \"aws:eu-south-1:postgress\" , \"infrastructureType\" : \"storage-resource\" } ] } The information provided so far are useful to track the infrastructural assets related to a specific data product. There are not anyway sufficient informtion to allow an external agent to provision the infrastructure autonomously. To this end in the Infrastructural Component there is the provisioningService filed that is described in much details in the next sections. Provisioning Service Object \u2693\ufe0e The Build Info Object contains the informations required to build an application component. DPDS uses integration pipelines as code to guarantee the possibility to automatize the build process in a riproducible way. Anyway to mantain technological indipendence the DPDS do not enforce the usage of any specific CICD tool. Fileds \u2693\ufe0e A Provisioning Info Object has the following three mandatory fields: service ( string:name or External Resource Object ): This is the logical name or the actual endpoint of the service to call in order to build the infrastructural component. If the logical name (ex. terraform , cloudformation , cdk , ecc...) is used as field value the actual endpoint value resulution is demanded to the data product experience plane of the underlyng platform. template ( object or External Resource Object ): This is the definition as code of the infrastructure to provision. It is passed as is to the provisioning service implementation specified in the service field. configurations ( object or External Resource Object ): This is the map of all configuration properties that must be used by the provisioning service at provisioning time. It is passed as is to the provisioning service implementation specified in the service field. Example \u2693\ufe0e The following example shows an appliction that could be built using a terraform backed provisioning service . The terraform file that contains the description of the infrastructure is available on an external bitbucket repository . The only configuration parameter passed in to the provision service at runtime is the name of the schema to create on the the target postgress db. { \"service\" : \"terraform\" , \"template\" : { \"mediaType\" : \"text/terraformfile\" , \"$href\" : \"https://bitbucket.org/company-xyz/trip-execution-infra-eventstore/src/master/main.tf\" }, \"configurations\" : { \"SCHEMA\" : \"shipments\" , } } Summary \u2693\ufe0e This page has shown that: a data product is composed not only by its public interface but also by internal componnets infrastructural components required by application components that implement services exposed by a data product through its ports are internal components described through an Infrastructural Component . Infrastructural Component contains general information related to the specific infrastructure component but also all the required information to provision the onfrastructure in an automatic and reproducible way. the DPDS uses infrastructure as code (IaC) to define how to provision infrastructure but do not enforce the use of any particular IaC tool, preserving in this way its technology independence . The next page describes how to reuse portions of an data product descriptor document to make it more readable and less redundant, reducing file size and maintenance cost.","title":"Infrastructural Components"},{"location":"quickstart/infrastructure/#infrastructural-components","text":"The previous page showed how to define the application components that implement the services exposed by a data product through its ports . This page explains how to define the infrastructural components required to execute these applications.","title":"Infrastructural Components"},{"location":"quickstart/infrastructure/#infrastructural-component-object","text":"Infrastructural components are internal components of a data product. This mean that, while the interface components are publicly available on demand to all consumers, access to infrastructural components can be restricted. All internal components of a data product are contained in the Internal Components Object , accessible through the internalComponents field in the root Data Product Descriptor Entity . Within this object the field infrastructuralComponents contains the list of all Infrastructural Component of the data product.","title":"Infrastructural Component Object"},{"location":"quickstart/infrastructure/#fields","text":"An Infrastructural Component has the following two mandatory fields: fullyQualifiedName (string:fqn): This is the unique universal idetifier of the component. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:infrastructure:{infra-name}. version (string:version): This is the semantic version number of the data product's infrastructural component. The version of infrastructural components have no direct impact of the version of the data product they belong to. A change in the major version of an infrastructural component can anyway impact the version of one interface components and so indirectly the version of the data product. Other non mandatory descriptive fields like platform and infrastructureType are also available. Moreover the Infrastructural Component can be extended with other fields with \"x-\" prefix as needed.","title":"Fields"},{"location":"quickstart/infrastructure/#example","text":"The following example shows two infrastructural components that respectively describe The topology of kafka topics required to store technical events generated by the cdcIngestion application while offloading data from the TMS source . domain events generated by eventProcessor application as composition of technical events that belong to the same transaction intercepted by cdcIngestion on the TMS source . The schema and and tables required by dbSinkConnector application to materialize from streamed domain events the updated state of each Trip . { \"infrastructuralComponents\" : [ { \"fullyQualifiedName\" : \"urn:dpds:com.company-xyz:dataproducts:tripExecution:1:infrastructure:eventStore\" , \"version\" : \"1.0.1\" , \"description\" : \"The kafka topics topology required to store technical events offloaded from TMS by the CDC and the domain events generetaed by eventProcessor application\" , \"platform\" : \"aws:eu-south-1:confluent\" , \"infrastructureType\" : \"storage-resource\" }, { \"fullyQualifiedName\" : \"urn:dpds:com.company-xyz:dataproducts:tripExecution:1:infrastructure:stateStore\" , \"version\" : \"1.0.0\" , \"description\" : \"The database used by dbSinkConnector application to store the Trip updated state\" , \"platform\" : \"aws:eu-south-1:postgress\" , \"infrastructureType\" : \"storage-resource\" } ] } The information provided so far are useful to track the infrastructural assets related to a specific data product. There are not anyway sufficient informtion to allow an external agent to provision the infrastructure autonomously. To this end in the Infrastructural Component there is the provisioningService filed that is described in much details in the next sections.","title":"Example"},{"location":"quickstart/infrastructure/#provisioning-service-object","text":"The Build Info Object contains the informations required to build an application component. DPDS uses integration pipelines as code to guarantee the possibility to automatize the build process in a riproducible way. Anyway to mantain technological indipendence the DPDS do not enforce the usage of any specific CICD tool.","title":"Provisioning Service Object"},{"location":"quickstart/infrastructure/#fileds","text":"A Provisioning Info Object has the following three mandatory fields: service ( string:name or External Resource Object ): This is the logical name or the actual endpoint of the service to call in order to build the infrastructural component. If the logical name (ex. terraform , cloudformation , cdk , ecc...) is used as field value the actual endpoint value resulution is demanded to the data product experience plane of the underlyng platform. template ( object or External Resource Object ): This is the definition as code of the infrastructure to provision. It is passed as is to the provisioning service implementation specified in the service field. configurations ( object or External Resource Object ): This is the map of all configuration properties that must be used by the provisioning service at provisioning time. It is passed as is to the provisioning service implementation specified in the service field.","title":"Fileds"},{"location":"quickstart/infrastructure/#example_1","text":"The following example shows an appliction that could be built using a terraform backed provisioning service . The terraform file that contains the description of the infrastructure is available on an external bitbucket repository . The only configuration parameter passed in to the provision service at runtime is the name of the schema to create on the the target postgress db. { \"service\" : \"terraform\" , \"template\" : { \"mediaType\" : \"text/terraformfile\" , \"$href\" : \"https://bitbucket.org/company-xyz/trip-execution-infra-eventstore/src/master/main.tf\" }, \"configurations\" : { \"SCHEMA\" : \"shipments\" , } }","title":"Example"},{"location":"quickstart/infrastructure/#summary","text":"This page has shown that: a data product is composed not only by its public interface but also by internal componnets infrastructural components required by application components that implement services exposed by a data product through its ports are internal components described through an Infrastructural Component . Infrastructural Component contains general information related to the specific infrastructure component but also all the required information to provision the onfrastructure in an automatic and reproducible way. the DPDS uses infrastructure as code (IaC) to define how to provision infrastructure but do not enforce the use of any particular IaC tool, preserving in this way its technology independence . The next page describes how to reuse portions of an data product descriptor document to make it more readable and less redundant, reducing file size and maintenance cost.","title":"Summary"},{"location":"quickstart/interface/","text":"Interface Components \u2693\ufe0e The previous page showed the minimal structure of a data product descriptor document but did not add any public interface to the data product. This page explains how to do it. Interface Components Object \u2693\ufe0e Data product interface components are called ports in the DPDS. The Interface Components Object , accessible through the interfaceComponents field in the root Data Product Descriptor Entity , is the container for all ports exposed by the data product. Fileds \u2693\ufe0e The Interface Components Object has five fields, one for each port type: inputPorts , outputPorts , discoveryPorts , observabilityPorts and controlPorts . Because a data product can expose multiple ports of the same type all these fields are Array of Objects . The type of these objects depends on the specific port type: Input Port Component , Output Port Component , Discovery Port Component , Observability Port Component and Control Port Component . Anyway all these objects share a common subset of fields, no metter what it is the type of the port to which they are associated with. The most important of these shared fields are: fullyQualifiedName ( string:fqn ): The unique universal idetifier of the port. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:{port-type}:{port-name} version : ( string:version ): This is the semantic version number of the data product's port. Everytime the major version of port changes also the major version of the product MUST be incremented. promises ( Promises Object ): This are the data product's promises declared over the port. expectations ( Expectations Object ): This are the data product's expectations declared over the port. contracts ( Contracts Object ): This are the data product's contracts declared over the port. Example \u2693\ufe0e Here a first example snippet of a port definition. More details on how to valorize promises , expectations and contracts fields are provided in the next subsections. { \"fullyQualifiedName\" : \"urn:dpds:com.company-xyz:dataproducts:tripExecution:1:outputports:tripStatus\" , \"name\" : \"tripStatus\" , \"displayName\" : \"Trip Status\" , \"description\" \"The last known status of each trip operated in the last 12 months\" \"version\" : \"1.2.0\" , \"promises\" : { ... }, \"expectations\" : { ... }, \"contracts\" : { ... } } Promises Object \u2693\ufe0e Through promises the data product declares the intent of the port. It's a set of implicit agreements between the data product and its consumers. Fields \u2693\ufe0e A Promises Object is composed by the following fields: platform ( string ): This is the target technological platform in which the services associated with the given port operate. Examples: onprem:milan-1 , aws:eu-south-1 , aws:eu-south-1:redshift . servicesType ( string ): This is the type of services associated with the given port. Examples: soap-services , rest-services , odata-services , streaming-services , datastore-services . api ( Standard Definition Object ): this is the formal description of services API. A good API standard specification should describe how to define the following elements of the service interface: addressable endpoints, available authentication methods and schema of data object exchanged. specification ( string ): This is the name of the specification used to define the service API. It is RECOMMENDED to use Open API Specification for restfull services, Async API Specification for streaming services and DataStore API Specification for data store connection based services. Other specifications MAY be used as required. version ( string ): This is the version of the specification used to define the service API. definition ( Object ): This is the definition of the service API built using the specification reported in the fields above depreceationPolicy ( Specification Extension Point ): This is the deprecation policy adopted for the given set of services. A policy description and a pointer to external documentation can be provided. Moreover other fields with \"x-\" prefix can be added to provide futher informations as needed (ex. x-deprecation-period ). description ( string ): This is a general description of the deprecation policy. externalDocs ( External Resource Object ): This is a pointer to external documentation that describe in more details the deprecation policy. slo : ( Specification Extension Point ): This are the service level objectives (SLO) supported by the given set of services. A SLO description and a pointer to external documentation can be provided. Moreover other fields with \"x-\" prefix can be added to provide futher informations as needed (ex. x-availability , x-responsetime , ecc...). description ( string ): This is a general description of the supported SLO externalDocs ( External Resource Object ): This is a pointer to external documentation that describe in more details the supported SLO. The Promises Object can be extended with other fields with \"x-\" prefix as needed. Example \u2693\ufe0e The promises of the following example describe a datastore service that expose one table (i.e. trip_status ) composed by two columns (i.e. id and status ) stored on a postgress db hostend in aws cloud . The description of the API is provided using a custom standard that is a simplified version of the DataStore API Specification . Both depreceationPolicy and slo fields use custom properties to provide more info respectivelly on the deprecation period duration (i.e. x-deprecation-period ) and on the service level indicators supported (i.e. x-operationalSlo and x-qualitySlo ) { \"platform\" : \"aws:eu-south-1:postgres\" , \"servicesType\" : \"datastore-services\" , \"api\" : { \"specification\" : \"custom-datastore-api\" , \"definition\" : { \"endpoints\" : [{ \"env\" : \"DEV\" , \"endpointType\" : \"jdbc\" , \"host\" : \"ip-10-24-32-0.ec2.internal\" , \"port\" : \"5432\" , \"db\" : \"tms\" , \"schema\" : \"shipments\" }], \"auth-methods\" : [ \"jdbc-base-authentication\" ], \"schema\" : { \"tables\" : [{ \"name\" : \"trip_status\" , \"displayName\" : \"Trip Status\" , \"tableType\" : \"LOCAL\" , \"columns\" : [ { \"name\" : \"id\" , \"displayName\" : \"Trip ID\" , \"dataType\" : \"INTEGER\" , \"columnConstraint\" : \"PRIMARY_KEY\" , \"ordinalPosition\" : 1 }, { \"name\" : \"status\" , \"displayName\" : \"Trip Status\" , \"dataType\" : \"VARCHAR\" , \"dataLength\" : \"30\" , \"columnConstraint\" : \"NOT_NULL\" , \"ordinalPosition\" : 2 }, ] }] } } }, \"depreceationPolicy\" : { \"description\" : \"When a new major version become available the previous one is kept online for 3 months\" , \"x-deprecation-period\" : \"3M\" , \"externalDocs\" : { \"description\" : \"A detailed description of the deprecation process\" , \"mediaType\" : \"text/html\" , \"$href\" : \"https://wiki.example-xyz.com/corporate-mesh/dp-deprecation-workflow.html\" } }, \"slo\" : { \"description\" : \"The slo are hight for all base service indicators because this service is business critical\" , \"x-operationalSlo\" : { \"availability\" : \"0.99999\" , \"responsetime\" : \"1s\" }, \"x-qualitySlo\" : { \"freshness\" : \"5m\" }, \"externalDocs\" : { \"description\" : \"A detailed description of the base service indicators that all data products must support\" , \"mediaType\" : \"text/html\" , \"$href\" : \"https://wiki.example-xyz.com/corporate-mesh/dp-base-service-indicators.html\" } }, } Expectations Object \u2693\ufe0e Through expectations the data product declares how it wants the port to be used by its consumers. Expectations are the inverse of promises. They are a way to explicitly state what promises the data product would like consumers to make regarding how they will use the port. Fields \u2693\ufe0e An Expectations Object is composed by the following fields: audience ( Specification Extension Point ): This is the audience of consumers for whom the the port has been designed. An audience description and a pointer to external documentation can be provided. Moreover other fields with \"x-\" prefix can be added to provide futher informations as needed (ex. x-includes , x-exclude , ecc...). description ( string ): This is a general description of the target service audience. externalDocs ( External Resource Object ): This is a pointer to external documentation that describe in more details the target service audience usage ( Specification Extension Point ): These are the usage patterns for which the port has been designed. A usage patterns description and a pointer to external documentation can be provided. Moreover other fields with \"x-\" prefix can be added to provide futher informations as needed (ex. x-filterOn , x-forbiddenOperations , ecc...). description ( string ): This is a general description of the intended usage patterns. externalDocs ( External Resource Object ): This is a pointer to external documentation that describe in more details the intended usage patterns. The Expectations Object can be extended with other fields with \"x-\" prefix as needed. Example \u2693\ufe0e The expectations of the following example describe a datastore service that has been designed to serve operations department and not customer service and finance department. It is also expected that the service is consumed for operational and not analytical workloads. Queries must be filtered on the id of the trip . Unfiltered selctions and queries with group-by clause are not expected to occure. { \"audience\" : { \"description\" : \"This port is designed to help operations departments. It is not for customer care and finance departments\" , \"x-includes\" : [ \"operations\" ], \"x-excludes\" : [ \"customer-care\" , \"finance\" ], \"externalDocs\" : { \"description\" : \"A detailed description of the data product, that include also the target audience\" , \"mediaType\" : \"text/html\" , \"$href\" : \"https://wiki.example-xyz.com/corporate-mesh/dp/trip-execution.html\" } }, \"usage\" : { \"description\" : \"This port is designed to operational access not for analysis\" , \"x-filterOn\" : [ \"id\" ], \"x-forbiddenOperations\" : [ \"group-by\" , \"unfiltered-selections\" ], \"externalDocs\" : { \"description\" : \"A detailed description of the data product, that include also the expected way to use it\" , \"mediaType\" : \"text/html\" , \"$href\" : \"https://wiki.example-xyz.com/corporate-mesh/dp/trip-execution.html\" } } } Contracts Object \u2693\ufe0e Through contracts the data product declares promises and expectations that must be respected by the data product and its consumers. A contract is an explicit agreement between the data product and its consumers. It is used to group all the promises and expectations that if not respected can generate penalties like monetary sanctions or interruption of service. Fields \u2693\ufe0e A Contracts Object is composed by the following fields: termsAndConditions ( Specification Extension Point ): These are the terms and conditions defined on the port on which consumers must agree on in order to use it. A short description of terms and conditions together with a pointer to a more detailed external documentation can be provided. Moreover other fields with \"x-\" prefix can be added to provide futher informations as needed. description ( string ): This is a short description of applied terms and conditions. externalDocs ( External Resource Object ): This is a pointer to a more detaild external documentation on applied terms and conditions. billingPolicy ( Specification Extension Point ): This is the billing policy defined on the port on which consumers must agree onin order to use it. A short description of billing policy together with a pointer to a more detailed external documentation can be provided. Moreover other fields with \"x-\" prefix can be added to provide futher informations as needed. description ( string ): This is a short description of applied terms and conditions. externalDocs ( External Resource Object ): This is a pointer to a more detaild external documentation on applied terms and conditions. sla ( Specification Extension Point ): These are the service level agreements (SLA) supported by the port. A short description of supported SLA together with a pointer to a more detailed external documentation can be provided. Moreover other fields with \"x-\" prefix can be added to provide futher informations as needed. description ( string ): This is a short description of supported SLA. externalDocs ( External Resource Object ): This is a pointer to a more detaild external documentation of supported SLA. The Contracts Object can be extended with other fields with \"x-\" prefix as needed. Example \u2693\ufe0e The contracts of the following example describe a datastore service billed monthly 0.001$ for each milion of executed queries. Terms and conditions of service are described in the internal wiki. A link to the specific session is provided, Finally the values of supported SLA are reported togheter with a link to the wiki page that describes the base service level indicators that each data product must support. { \"termsAndConditions\" : { \"description\" : \"A detailed description of the data product, that include also the target audience\" , \"mediaType\" : \"text/html\" , \"$href\" : \"https://wiki.example-xyz.com/corporate-mesh/dp/trip-execution.html#terms-and-conditions\" }, \"billingPolicy\" : { \"description\" : \"This port is billed by number of monthly queries\" , \"x-billingUnit\" : \"milion queries\" , \"x-pricePerUnit\" : 0.01 , \"x-billingPeriod\" : \"month\" , \"externalDocs\" : { \"description\" : \"A detailed description of the data product, that include also the billing policy\" , \"mediaType\" : \"text/html\" , \"$href\" : \"https://wiki.example-xyz.com/corporate-mesh/dp/trip-execution.html#billing\" } }, \"sla\" : { \"description\" : \"The sla are hight for all base service indicators because this service is business critical\" , \"x-operationalSla\" : { \"availability\" : \"0.999\" , \"responsetime\" : \"5s\" }, \"x-qualitySla\" : { \"freshness\" : \"10m\" }, \"externalDocs\" : { \"description\" : \"A detailed description of the base service indicators that all data products must support\" , \"mediaType\" : \"text/html\" , \"$href\" : \"https://wiki.example-xyz.com/corporate-mesh/dp-base-service-indicators.html\" } }, } Summary \u2693\ufe0e This page has shown that: DPDS groups services exposed by a data product in ports. Five types of port are supported by DPDS: input port, output port, discovery port, observability port and control port. The description of the interface of all ports exposed by a data product is contained in the Interface Components Object . each data product can have multiple ports of the same type. the interface of each port, independently by the specific type, is described through promises , expectations and crontracts fields. The next page describes the contents of the applicationComponents field used to provide all the required information to build and deploy applications that implement the services exposed by the product through its ports.","title":"Interface Components"},{"location":"quickstart/interface/#interface-components","text":"The previous page showed the minimal structure of a data product descriptor document but did not add any public interface to the data product. This page explains how to do it.","title":"Interface Components"},{"location":"quickstart/interface/#interface-components-object","text":"Data product interface components are called ports in the DPDS. The Interface Components Object , accessible through the interfaceComponents field in the root Data Product Descriptor Entity , is the container for all ports exposed by the data product.","title":"Interface Components Object"},{"location":"quickstart/interface/#fileds","text":"The Interface Components Object has five fields, one for each port type: inputPorts , outputPorts , discoveryPorts , observabilityPorts and controlPorts . Because a data product can expose multiple ports of the same type all these fields are Array of Objects . The type of these objects depends on the specific port type: Input Port Component , Output Port Component , Discovery Port Component , Observability Port Component and Control Port Component . Anyway all these objects share a common subset of fields, no metter what it is the type of the port to which they are associated with. The most important of these shared fields are: fullyQualifiedName ( string:fqn ): The unique universal idetifier of the port. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:{port-type}:{port-name} version : ( string:version ): This is the semantic version number of the data product's port. Everytime the major version of port changes also the major version of the product MUST be incremented. promises ( Promises Object ): This are the data product's promises declared over the port. expectations ( Expectations Object ): This are the data product's expectations declared over the port. contracts ( Contracts Object ): This are the data product's contracts declared over the port.","title":"Fileds"},{"location":"quickstart/interface/#example","text":"Here a first example snippet of a port definition. More details on how to valorize promises , expectations and contracts fields are provided in the next subsections. { \"fullyQualifiedName\" : \"urn:dpds:com.company-xyz:dataproducts:tripExecution:1:outputports:tripStatus\" , \"name\" : \"tripStatus\" , \"displayName\" : \"Trip Status\" , \"description\" \"The last known status of each trip operated in the last 12 months\" \"version\" : \"1.2.0\" , \"promises\" : { ... }, \"expectations\" : { ... }, \"contracts\" : { ... } }","title":"Example"},{"location":"quickstart/interface/#promises-object","text":"Through promises the data product declares the intent of the port. It's a set of implicit agreements between the data product and its consumers.","title":"Promises Object"},{"location":"quickstart/interface/#fields","text":"A Promises Object is composed by the following fields: platform ( string ): This is the target technological platform in which the services associated with the given port operate. Examples: onprem:milan-1 , aws:eu-south-1 , aws:eu-south-1:redshift . servicesType ( string ): This is the type of services associated with the given port. Examples: soap-services , rest-services , odata-services , streaming-services , datastore-services . api ( Standard Definition Object ): this is the formal description of services API. A good API standard specification should describe how to define the following elements of the service interface: addressable endpoints, available authentication methods and schema of data object exchanged. specification ( string ): This is the name of the specification used to define the service API. It is RECOMMENDED to use Open API Specification for restfull services, Async API Specification for streaming services and DataStore API Specification for data store connection based services. Other specifications MAY be used as required. version ( string ): This is the version of the specification used to define the service API. definition ( Object ): This is the definition of the service API built using the specification reported in the fields above depreceationPolicy ( Specification Extension Point ): This is the deprecation policy adopted for the given set of services. A policy description and a pointer to external documentation can be provided. Moreover other fields with \"x-\" prefix can be added to provide futher informations as needed (ex. x-deprecation-period ). description ( string ): This is a general description of the deprecation policy. externalDocs ( External Resource Object ): This is a pointer to external documentation that describe in more details the deprecation policy. slo : ( Specification Extension Point ): This are the service level objectives (SLO) supported by the given set of services. A SLO description and a pointer to external documentation can be provided. Moreover other fields with \"x-\" prefix can be added to provide futher informations as needed (ex. x-availability , x-responsetime , ecc...). description ( string ): This is a general description of the supported SLO externalDocs ( External Resource Object ): This is a pointer to external documentation that describe in more details the supported SLO. The Promises Object can be extended with other fields with \"x-\" prefix as needed.","title":"Fields"},{"location":"quickstart/interface/#example_1","text":"The promises of the following example describe a datastore service that expose one table (i.e. trip_status ) composed by two columns (i.e. id and status ) stored on a postgress db hostend in aws cloud . The description of the API is provided using a custom standard that is a simplified version of the DataStore API Specification . Both depreceationPolicy and slo fields use custom properties to provide more info respectivelly on the deprecation period duration (i.e. x-deprecation-period ) and on the service level indicators supported (i.e. x-operationalSlo and x-qualitySlo ) { \"platform\" : \"aws:eu-south-1:postgres\" , \"servicesType\" : \"datastore-services\" , \"api\" : { \"specification\" : \"custom-datastore-api\" , \"definition\" : { \"endpoints\" : [{ \"env\" : \"DEV\" , \"endpointType\" : \"jdbc\" , \"host\" : \"ip-10-24-32-0.ec2.internal\" , \"port\" : \"5432\" , \"db\" : \"tms\" , \"schema\" : \"shipments\" }], \"auth-methods\" : [ \"jdbc-base-authentication\" ], \"schema\" : { \"tables\" : [{ \"name\" : \"trip_status\" , \"displayName\" : \"Trip Status\" , \"tableType\" : \"LOCAL\" , \"columns\" : [ { \"name\" : \"id\" , \"displayName\" : \"Trip ID\" , \"dataType\" : \"INTEGER\" , \"columnConstraint\" : \"PRIMARY_KEY\" , \"ordinalPosition\" : 1 }, { \"name\" : \"status\" , \"displayName\" : \"Trip Status\" , \"dataType\" : \"VARCHAR\" , \"dataLength\" : \"30\" , \"columnConstraint\" : \"NOT_NULL\" , \"ordinalPosition\" : 2 }, ] }] } } }, \"depreceationPolicy\" : { \"description\" : \"When a new major version become available the previous one is kept online for 3 months\" , \"x-deprecation-period\" : \"3M\" , \"externalDocs\" : { \"description\" : \"A detailed description of the deprecation process\" , \"mediaType\" : \"text/html\" , \"$href\" : \"https://wiki.example-xyz.com/corporate-mesh/dp-deprecation-workflow.html\" } }, \"slo\" : { \"description\" : \"The slo are hight for all base service indicators because this service is business critical\" , \"x-operationalSlo\" : { \"availability\" : \"0.99999\" , \"responsetime\" : \"1s\" }, \"x-qualitySlo\" : { \"freshness\" : \"5m\" }, \"externalDocs\" : { \"description\" : \"A detailed description of the base service indicators that all data products must support\" , \"mediaType\" : \"text/html\" , \"$href\" : \"https://wiki.example-xyz.com/corporate-mesh/dp-base-service-indicators.html\" } }, }","title":"Example"},{"location":"quickstart/interface/#expectations-object","text":"Through expectations the data product declares how it wants the port to be used by its consumers. Expectations are the inverse of promises. They are a way to explicitly state what promises the data product would like consumers to make regarding how they will use the port.","title":"Expectations Object"},{"location":"quickstart/interface/#fields_1","text":"An Expectations Object is composed by the following fields: audience ( Specification Extension Point ): This is the audience of consumers for whom the the port has been designed. An audience description and a pointer to external documentation can be provided. Moreover other fields with \"x-\" prefix can be added to provide futher informations as needed (ex. x-includes , x-exclude , ecc...). description ( string ): This is a general description of the target service audience. externalDocs ( External Resource Object ): This is a pointer to external documentation that describe in more details the target service audience usage ( Specification Extension Point ): These are the usage patterns for which the port has been designed. A usage patterns description and a pointer to external documentation can be provided. Moreover other fields with \"x-\" prefix can be added to provide futher informations as needed (ex. x-filterOn , x-forbiddenOperations , ecc...). description ( string ): This is a general description of the intended usage patterns. externalDocs ( External Resource Object ): This is a pointer to external documentation that describe in more details the intended usage patterns. The Expectations Object can be extended with other fields with \"x-\" prefix as needed.","title":"Fields"},{"location":"quickstart/interface/#example_2","text":"The expectations of the following example describe a datastore service that has been designed to serve operations department and not customer service and finance department. It is also expected that the service is consumed for operational and not analytical workloads. Queries must be filtered on the id of the trip . Unfiltered selctions and queries with group-by clause are not expected to occure. { \"audience\" : { \"description\" : \"This port is designed to help operations departments. It is not for customer care and finance departments\" , \"x-includes\" : [ \"operations\" ], \"x-excludes\" : [ \"customer-care\" , \"finance\" ], \"externalDocs\" : { \"description\" : \"A detailed description of the data product, that include also the target audience\" , \"mediaType\" : \"text/html\" , \"$href\" : \"https://wiki.example-xyz.com/corporate-mesh/dp/trip-execution.html\" } }, \"usage\" : { \"description\" : \"This port is designed to operational access not for analysis\" , \"x-filterOn\" : [ \"id\" ], \"x-forbiddenOperations\" : [ \"group-by\" , \"unfiltered-selections\" ], \"externalDocs\" : { \"description\" : \"A detailed description of the data product, that include also the expected way to use it\" , \"mediaType\" : \"text/html\" , \"$href\" : \"https://wiki.example-xyz.com/corporate-mesh/dp/trip-execution.html\" } } }","title":"Example"},{"location":"quickstart/interface/#contracts-object","text":"Through contracts the data product declares promises and expectations that must be respected by the data product and its consumers. A contract is an explicit agreement between the data product and its consumers. It is used to group all the promises and expectations that if not respected can generate penalties like monetary sanctions or interruption of service.","title":"Contracts Object"},{"location":"quickstart/interface/#fields_2","text":"A Contracts Object is composed by the following fields: termsAndConditions ( Specification Extension Point ): These are the terms and conditions defined on the port on which consumers must agree on in order to use it. A short description of terms and conditions together with a pointer to a more detailed external documentation can be provided. Moreover other fields with \"x-\" prefix can be added to provide futher informations as needed. description ( string ): This is a short description of applied terms and conditions. externalDocs ( External Resource Object ): This is a pointer to a more detaild external documentation on applied terms and conditions. billingPolicy ( Specification Extension Point ): This is the billing policy defined on the port on which consumers must agree onin order to use it. A short description of billing policy together with a pointer to a more detailed external documentation can be provided. Moreover other fields with \"x-\" prefix can be added to provide futher informations as needed. description ( string ): This is a short description of applied terms and conditions. externalDocs ( External Resource Object ): This is a pointer to a more detaild external documentation on applied terms and conditions. sla ( Specification Extension Point ): These are the service level agreements (SLA) supported by the port. A short description of supported SLA together with a pointer to a more detailed external documentation can be provided. Moreover other fields with \"x-\" prefix can be added to provide futher informations as needed. description ( string ): This is a short description of supported SLA. externalDocs ( External Resource Object ): This is a pointer to a more detaild external documentation of supported SLA. The Contracts Object can be extended with other fields with \"x-\" prefix as needed.","title":"Fields"},{"location":"quickstart/interface/#example_3","text":"The contracts of the following example describe a datastore service billed monthly 0.001$ for each milion of executed queries. Terms and conditions of service are described in the internal wiki. A link to the specific session is provided, Finally the values of supported SLA are reported togheter with a link to the wiki page that describes the base service level indicators that each data product must support. { \"termsAndConditions\" : { \"description\" : \"A detailed description of the data product, that include also the target audience\" , \"mediaType\" : \"text/html\" , \"$href\" : \"https://wiki.example-xyz.com/corporate-mesh/dp/trip-execution.html#terms-and-conditions\" }, \"billingPolicy\" : { \"description\" : \"This port is billed by number of monthly queries\" , \"x-billingUnit\" : \"milion queries\" , \"x-pricePerUnit\" : 0.01 , \"x-billingPeriod\" : \"month\" , \"externalDocs\" : { \"description\" : \"A detailed description of the data product, that include also the billing policy\" , \"mediaType\" : \"text/html\" , \"$href\" : \"https://wiki.example-xyz.com/corporate-mesh/dp/trip-execution.html#billing\" } }, \"sla\" : { \"description\" : \"The sla are hight for all base service indicators because this service is business critical\" , \"x-operationalSla\" : { \"availability\" : \"0.999\" , \"responsetime\" : \"5s\" }, \"x-qualitySla\" : { \"freshness\" : \"10m\" }, \"externalDocs\" : { \"description\" : \"A detailed description of the base service indicators that all data products must support\" , \"mediaType\" : \"text/html\" , \"$href\" : \"https://wiki.example-xyz.com/corporate-mesh/dp-base-service-indicators.html\" } }, }","title":"Example"},{"location":"quickstart/interface/#summary","text":"This page has shown that: DPDS groups services exposed by a data product in ports. Five types of port are supported by DPDS: input port, output port, discovery port, observability port and control port. The description of the interface of all ports exposed by a data product is contained in the Interface Components Object . each data product can have multiple ports of the same type. the interface of each port, independently by the specific type, is described through promises , expectations and crontracts fields. The next page describes the contents of the applicationComponents field used to provide all the required information to build and deploy applications that implement the services exposed by the product through its ports.","title":"Summary"},{"location":"quickstart/overview/","text":"Descriptor Document Overview \u2693\ufe0e A data product descriptor document describes a data product in one or more machine-readable files. This page describes the syntax of these files and the minimal structure they must contain. Document Syntax \u2693\ufe0e A data product descriptor document is a text file, commonly called data-product-descriptor.json or data-product-descriptor.yaml , representing a JSON object, in either JSON or YAML format. This file is called the root document and it can be split into multiple JSON or YAML files, for clarity. This section very briefly describes these two formats and compares them. JSON can represent Numbers , Strings , Booleans , null values , Arrays and Objects . An array is an ordered list of values which can have different types. An object (also called a Map) is a collection of name-value pairs where the names (also called Keys or Fields) are unique within the object and the values can have any of the supported types (including other objects or arrays). Here\u2019s a comparison showing the different syntaxes. JSON: { \"anObject\" : { \"aNumber\" : 42 , \"aString\" : \"This is a string\" , \"aBoolean\" : true , \"nothing\" : null , \"arrayOfNumbers\" : [ 1 , 2 , 3 ] } } YAML: # Anything after a hash sign is a comment anObject : aNumber : 42 aString : This is a string aBoolean : true nothing : null arrayOfNumbers : - 1 - 2 - 3 Basically, JSON does not support comments and requires: commas separating fields, curly brackets around objects, double quotation marks around strings and square brackets around arrays. On the other hand, YAML requires hyphens before array items and relies heavily on indentation, which can be cumbersome on large files (indentation is entirely optional in JSON). The two formats are completely interchangeable (as long as YAML 1.2 is used). All examples in these pages will be given in JSON. Because YAML is a superset of JSON both syntaxes can also be mixed. While this is not recommended in general, it can come in handy sometimes. For example: anObject : aString : This is a string arrayOfNumbers : [ 1 , 2 , 3 ] # Abbreviated array representation Finally, object field names are case-sensitive: dataproductdescriptor is not the same thing as dataProductDescriptor . Document Structure \u2693\ufe0e To be entirely precise, a data product descriptor document is a single JSON object containing fields adhering to the structure defined in the Data Product Descriptor Specification (DPDS) . The DPDS devides the structure of a data product descriptor document in the following three main parts: general info interface components internal components The content of general info part and interface components part are shared with other data products and the platform to enable products discoverbility and self service usage. Internal component insted are accessible only to the product team and to the platform. Summary \u2693\ufe0e This page has shown that: The syntax (language) used to write data product descriptor documents can be JSON , YAML or both . A data product descriptor document is a JSON (or YAML) object including the fields described in the Data Product Descriptor Specification (DPDS) . The next page describes the minimal set of fields required to create a valid data product descriptor document.","title":"Descriptor Document Overview"},{"location":"quickstart/overview/#descriptor-document-overview","text":"A data product descriptor document describes a data product in one or more machine-readable files. This page describes the syntax of these files and the minimal structure they must contain.","title":"Descriptor Document Overview"},{"location":"quickstart/overview/#document-syntax","text":"A data product descriptor document is a text file, commonly called data-product-descriptor.json or data-product-descriptor.yaml , representing a JSON object, in either JSON or YAML format. This file is called the root document and it can be split into multiple JSON or YAML files, for clarity. This section very briefly describes these two formats and compares them. JSON can represent Numbers , Strings , Booleans , null values , Arrays and Objects . An array is an ordered list of values which can have different types. An object (also called a Map) is a collection of name-value pairs where the names (also called Keys or Fields) are unique within the object and the values can have any of the supported types (including other objects or arrays). Here\u2019s a comparison showing the different syntaxes. JSON: { \"anObject\" : { \"aNumber\" : 42 , \"aString\" : \"This is a string\" , \"aBoolean\" : true , \"nothing\" : null , \"arrayOfNumbers\" : [ 1 , 2 , 3 ] } } YAML: # Anything after a hash sign is a comment anObject : aNumber : 42 aString : This is a string aBoolean : true nothing : null arrayOfNumbers : - 1 - 2 - 3 Basically, JSON does not support comments and requires: commas separating fields, curly brackets around objects, double quotation marks around strings and square brackets around arrays. On the other hand, YAML requires hyphens before array items and relies heavily on indentation, which can be cumbersome on large files (indentation is entirely optional in JSON). The two formats are completely interchangeable (as long as YAML 1.2 is used). All examples in these pages will be given in JSON. Because YAML is a superset of JSON both syntaxes can also be mixed. While this is not recommended in general, it can come in handy sometimes. For example: anObject : aString : This is a string arrayOfNumbers : [ 1 , 2 , 3 ] # Abbreviated array representation Finally, object field names are case-sensitive: dataproductdescriptor is not the same thing as dataProductDescriptor .","title":"Document Syntax"},{"location":"quickstart/overview/#document-structure","text":"To be entirely precise, a data product descriptor document is a single JSON object containing fields adhering to the structure defined in the Data Product Descriptor Specification (DPDS) . The DPDS devides the structure of a data product descriptor document in the following three main parts: general info interface components internal components The content of general info part and interface components part are shared with other data products and the platform to enable products discoverbility and self service usage. Internal component insted are accessible only to the product team and to the platform.","title":"Document Structure"},{"location":"quickstart/overview/#summary","text":"This page has shown that: The syntax (language) used to write data product descriptor documents can be JSON , YAML or both . A data product descriptor document is a JSON (or YAML) object including the fields described in the Data Product Descriptor Specification (DPDS) . The next page describes the minimal set of fields required to create a valid data product descriptor document.","title":"Summary"},{"location":"references/","text":"References \u2693\ufe0e TODO (this page will contain the table of content for this session. used only from gitub)","title":"References"},{"location":"references/#references","text":"TODO (this page will contain the table of content for this session. used only from gitub)","title":"References"},{"location":"references/examples/","text":"Examples \u2693\ufe0e TODO","title":"Examples"},{"location":"references/examples/#examples","text":"TODO","title":"Examples"},{"location":"references/resources/","text":"Data Mesh Resources \u2693\ufe0e TODO Zhamak's Corner \u2693\ufe0e Zhamak Dehghani formalized the data mesh approach to data management in 2019 while working at Thoughtworks as the director of emerging technologies. Since then Zhamak has continued to work to disseminate and evolve the data mesh approach within the data and business community. Today she is the CEO and founder of a stealth startup and undoubtedly one of the most important reference in the data mesh world. Resource Date Description How to Move Beyond a Monolithic Data Lake to a Distributed Data Mesh May 2019 This is the first Zhamak\u2019s data mesh article posted on Martin Fowler\u2019s blog. She focuses here on recurrent problems in data management and propose data mesh as a new apprach to solve them. Data Mesh Principles and Logical Architecture December 2020 This is the second Zhamak\u2019s article on Martin Fowler\u2019s blog where she delves deeper into data mesh approach and its key priciples. Introduction to Data Mesh June 2022 This is a more recent presentation made by Zhamak at the Stanford Deep Data Research Computing Center. The concepts are the same of the previous two articles but they are refined and extended. The four principles of Data Mesh NA This is a series of webinars, each one focusing on one of the data forur data mesh key principles. Data Mesh March 2022 This book it is as for now the ultimate reference for the data mesh apprach to data management. Software Architecture: The Hard Parts October 2021 In this book Zhamak curates the parts related to data architectures. Communities \u2693\ufe0e TODO Resource Description Data Mesh Learning Community This is a vendor-independent learning resource created to teach people about data mesh. This website centralize data mesh content and address common data mesh questions and misconceptions. There is also a Slack channel associated with the site to discuss about data mesh topics with other community members. Podcasts \u2693\ufe0e TODO Resource Description Data Mesh Radio Podcast This podcast hosted by Scott Hirleman , the co-founder of the Data Mesh Learning Community , focuses on topics that are near and dear to those implementing \u2013 or considering implementing \u2013 data mesh. Data Engineering Podcast This podcast hosted by Tobias Macey tackles a new approach to data management every week. Each new episode provides useful and informative insights into the projects, platforms, and practices that data engineers, team leaders, and data scientists need to know about to learn and grow in their career. Catalogue & Cocktails Podcast This podcast hosted by Juan Sequeda and Tim Gasper is an honest, no-bs, non-salesy conversation about enterprise data management and analytics. Other data mesh resources \u2693\ufe0e Impossible to mention all. TODO ... Resource Description Data Mesh Architecture This website is a nice 360 degree intro to data mesh from an engineering prespective. State of Data Mesh 2022 This website contains the video recording of the sections of last State Data Mesh conference (2022). This conference yearly hosted by Thoughtworks focuses on the current and future state of Data Mesh discovering lessons learned from industry leaders that have adopted it and technologists that have implemented it, and exploring perspectives from leading vendors in the space. Big Data LDN 2022 This is the youtube channel of Big Data LDN conference. It cpontains a lot of video filmed during 2022 edition of the conference. Lot of them are related to data mesh. Other data management resources \u2693\ufe0e TODO Resource Description Data Management at Scale TODO also check Data Management at Scale, 2nd Edition Fundamentals of Data Engineering TODO Team Topologies TODO Peopleware: Productive Projects and Teams TODO EDGE: Value-Driven Digital Transformation TODO Thinking in Systems TODO Thinking in Promises TODO Building a Scalable Data Warehouse with Data Vault 2.0 TODO Building Evolutionary Architectures TODO Designing Delivery TODO Domain-Driven Design: Tackling Complexity in the Heart of Software TODO Implementing Domain-Driven Design TODO Software Wasteland: How the Application-Centric Mindset is Hobbling our Enterprises TODO The Data-Centric Revolution: Restoring Sanity to Enterprise Information Systems TODO","title":"Data Mesh Resources"},{"location":"references/resources/#data-mesh-resources","text":"TODO","title":"Data Mesh Resources"},{"location":"references/resources/#zhamaks-corner","text":"Zhamak Dehghani formalized the data mesh approach to data management in 2019 while working at Thoughtworks as the director of emerging technologies. Since then Zhamak has continued to work to disseminate and evolve the data mesh approach within the data and business community. Today she is the CEO and founder of a stealth startup and undoubtedly one of the most important reference in the data mesh world. Resource Date Description How to Move Beyond a Monolithic Data Lake to a Distributed Data Mesh May 2019 This is the first Zhamak\u2019s data mesh article posted on Martin Fowler\u2019s blog. She focuses here on recurrent problems in data management and propose data mesh as a new apprach to solve them. Data Mesh Principles and Logical Architecture December 2020 This is the second Zhamak\u2019s article on Martin Fowler\u2019s blog where she delves deeper into data mesh approach and its key priciples. Introduction to Data Mesh June 2022 This is a more recent presentation made by Zhamak at the Stanford Deep Data Research Computing Center. The concepts are the same of the previous two articles but they are refined and extended. The four principles of Data Mesh NA This is a series of webinars, each one focusing on one of the data forur data mesh key principles. Data Mesh March 2022 This book it is as for now the ultimate reference for the data mesh apprach to data management. Software Architecture: The Hard Parts October 2021 In this book Zhamak curates the parts related to data architectures.","title":"Zhamak's Corner"},{"location":"references/resources/#communities","text":"TODO Resource Description Data Mesh Learning Community This is a vendor-independent learning resource created to teach people about data mesh. This website centralize data mesh content and address common data mesh questions and misconceptions. There is also a Slack channel associated with the site to discuss about data mesh topics with other community members.","title":"Communities"},{"location":"references/resources/#podcasts","text":"TODO Resource Description Data Mesh Radio Podcast This podcast hosted by Scott Hirleman , the co-founder of the Data Mesh Learning Community , focuses on topics that are near and dear to those implementing \u2013 or considering implementing \u2013 data mesh. Data Engineering Podcast This podcast hosted by Tobias Macey tackles a new approach to data management every week. Each new episode provides useful and informative insights into the projects, platforms, and practices that data engineers, team leaders, and data scientists need to know about to learn and grow in their career. Catalogue & Cocktails Podcast This podcast hosted by Juan Sequeda and Tim Gasper is an honest, no-bs, non-salesy conversation about enterprise data management and analytics.","title":"Podcasts"},{"location":"references/resources/#other-data-mesh-resources","text":"Impossible to mention all. TODO ... Resource Description Data Mesh Architecture This website is a nice 360 degree intro to data mesh from an engineering prespective. State of Data Mesh 2022 This website contains the video recording of the sections of last State Data Mesh conference (2022). This conference yearly hosted by Thoughtworks focuses on the current and future state of Data Mesh discovering lessons learned from industry leaders that have adopted it and technologists that have implemented it, and exploring perspectives from leading vendors in the space. Big Data LDN 2022 This is the youtube channel of Big Data LDN conference. It cpontains a lot of video filmed during 2022 edition of the conference. Lot of them are related to data mesh.","title":"Other data mesh resources"},{"location":"references/resources/#other-data-management-resources","text":"TODO Resource Description Data Management at Scale TODO also check Data Management at Scale, 2nd Edition Fundamentals of Data Engineering TODO Team Topologies TODO Peopleware: Productive Projects and Teams TODO EDGE: Value-Driven Digital Transformation TODO Thinking in Systems TODO Thinking in Promises TODO Building a Scalable Data Warehouse with Data Vault 2.0 TODO Building Evolutionary Architectures TODO Designing Delivery TODO Domain-Driven Design: Tackling Complexity in the Heart of Software TODO Implementing Domain-Driven Design TODO Software Wasteland: How the Application-Centric Mindset is Hobbling our Enterprises TODO The Data-Centric Revolution: Restoring Sanity to Enterprise Information Systems TODO","title":"Other data management resources"},{"location":"references/standards/","text":"Related Standards \u2693\ufe0e TODO API \u2693\ufe0e TODO Standard Description OpenAPI TODO AsyncAPI TODO DatastoreAPI TODO Schemas \u2693\ufe0e TODO Standard Description JSON Schema TODO Open Metadata TODO Avro TODO Protocol Buffers TODO Observability \u2693\ufe0e TODO Standard Description Open Tracing TODO Open Lineage TODO Open SLO TODO Computational Governance \u2693\ufe0e TODO Standard Description Open Policy Agent TODO Great Expectations TODO Soda TODO Misc \u2693\ufe0e TODO Standard Description Data Product Specification (by Agile Lab) TODO","title":"Related Standards"},{"location":"references/standards/#related-standards","text":"TODO","title":"Related Standards"},{"location":"references/standards/#api","text":"TODO Standard Description OpenAPI TODO AsyncAPI TODO DatastoreAPI TODO","title":"API"},{"location":"references/standards/#schemas","text":"TODO Standard Description JSON Schema TODO Open Metadata TODO Avro TODO Protocol Buffers TODO","title":"Schemas"},{"location":"references/standards/#observability","text":"TODO Standard Description Open Tracing TODO Open Lineage TODO Open SLO TODO","title":"Observability"},{"location":"references/standards/#computational-governance","text":"TODO Standard Description Open Policy Agent TODO Great Expectations TODO Soda TODO","title":"Computational Governance"},{"location":"references/standards/#misc","text":"TODO Standard Description Data Product Specification (by Agile Lab) TODO","title":"Misc"},{"location":"references/tools/","text":"External Tools \u2693\ufe0e TODO Open Data Mesh Platform \u2693\ufe0e TODO Blindata.io \u2693\ufe0e TODO","title":"External Tools"},{"location":"references/tools/#external-tools","text":"TODO","title":"External Tools"},{"location":"references/tools/#open-data-mesh-platform","text":"TODO","title":"Open Data Mesh Platform"},{"location":"references/tools/#blindataio","text":"TODO","title":"Blindata.io"},{"location":"references/schemas/","text":"JSON Schema Versions \u2693\ufe0e TODO DPDS v1.0.0","title":"Versions"},{"location":"references/schemas/#json-schema-versions","text":"TODO DPDS v1.0.0","title":"JSON Schema Versions"},{"location":"references/schemas/2.0.0/","text":"Data Product Descriptor Specification \u2693\ufe0e Version 2.0.0 \u2693\ufe0e The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 RFC2119 RFC8174 when, and only when, they appear in all capitals, as shown here. This document is licensed under The Apache License, Version 2.0 . Disclaimer \u2693\ufe0e Part of this content has been taken from the great work done by the folks at the OpenAPI Initiative and AsyncAPI Initiative . We have decided to not reinvent the wheel and inspire our work to these two specifications mainly for the following reasons: We think that the work made by OpenAPI Initiative and AsyncAPI Initiative is great :) We want to make the learning curve for the Data Product Descriptor Specification as smooth as possible, aligning its definition to the one of other two popular specifications in the software and data engineers community We think that OpenAPI and AsyncAPI are natural specifications for defining the interface of data product's ports that expose an API endpoint. This specification do not impose to use any specific standard for port's interface definition but these two are highly recommended. Introduction \u2693\ufe0e The Data Product Descriptor Specification (DPDS) defines a declarative and technology independent standard to describe a data product in all its components. It allows human agents (e.g. analysts, data scientists, etc..) and digital agents (e.g. other data products, BI tools, planes of the underlying data mesh ops platform, etc..) to operate, discover and access a data product. When properly defined, an external agent can understand and interact with the data product with a minimal amount of cognitive load and implementation logic. The formalization of a standard data product descriptor document through an open specification is useful to enable the implementation of an ecosystem of interoperable data mesh tools. The following is a non exhaustive list of tools that can benefit from the specification: catalogs (search, document and collaborate) design tools (create new products by composition of reusable templates) lifecycle management tools (deploy and operate) access management tools (assign/track access grants and generate client code in different languages) policies checking tools (enforce standard compliance and audit security) observability tools (monitor and detect) data lineage tools (trace data flows and perform forward/backward analysis) mesh topology analysis tools (calculate value/trust scores and detect structural problems) semantic tools (apply ontologies over mesh topology) domain specific language tools (create a collection af interconnected data products that implement together a specific value stream) Table of Contents \u2693\ufe0e Definitions Standard Standard Specification Standard Definition Data Product Data Product Ports Data Product Application Components Data Product Infrastructure Components Data Product Descriptor Document Data Product Descriptor Specification Specification Versions Format Document Structure Data Types Rich Text Formatting Relative References In URLs Schema Data Product Descriptor Entity Info Object Owner Object Contact Point Object Interface Components Object Input Port Component Output Port Component Discovery Port Component Observability Port Component Control Port Component Promises Object Expectations Object Contracts Object Internal Components Object Application Component Infrastructural Component Components Object Reference Object External Resource Object Standard Definition Object Specification Extension Point Specification Extensions Appendix A: Revision History Definitions \u2693\ufe0e Standard \u2693\ufe0e The set of shared rules used by different agents to describe an entity or process of common interest. The agents that follow the standard limit their autonomy conforming to the set of shared rules in order to facilitate cooperation between them through interoperability. Standard Specification \u2693\ufe0e The formal description of the rules that form a standard . A standard can have multiple specification versions associated to it. Sometime the words standard and specification are used as synonymous. Standard Definition \u2693\ufe0e The description of one specific entity or process created using and conforming to the set of rules formally described in the standard specification Data Product \u2693\ufe0e The smallest unit that can be independently deployed and managed in a data architecture (i.e. architectural quantum). It is composed by all the structural components that it requires to do its function: metadata, data, code, policies that govern the data and its dependencies to infrastructure. Each data product has a clear identifier, a version number and an owner. Data Product Ports \u2693\ufe0e The interfaces exposed to external agents by a data product . Each port expose a service or set of correlated services. These are the five types of port supported by a data product : Input port(s): an input port describes a set of services exposed by a data product to collect its source data and makes it available for further internal transformation. An input port can receive data from one ore more upstream sources in a push (i.e. asynchronous subscription) or pop mode (i.e. synchronous query). Each data product may have one or more input ports. Output port(s): an output port describes a set of services exposed by a data product to share the generated data in a way that can be understood and trusted. Each data product may have one or more output ports. Discovery port(s): a discovery port describes a set of services exposed by a data product to provide information about its static role in the overall architecture like purpose, structure, location, etc.. Each data product may have one or multiple discovery ports. Observability port(s): an observability port describes a set of services exposed by a data product to provide information about its dynamic behaviour in the overall architecture like logs, traces, audit trails, metrics, etc.. Each data product may have one or more observability ports. Control port(s): a control port describes a set of services exposed by a data product to configure local policies or perform highly privileged governance operations. Each data product may have one or more control ports. The data product descriptor specification uses the following concepts of promises theory to formally describe the set of services exposed by each port regardless of the specific type: Promises: Through promises the data product declares the intent of the port. Promises are not a guarantee of the outcome but the data product will behave accordingly to them in order to realize its intent. The more a data product keeps its promises over time and the more trustworthy it is. Thus, the more trustworthy a data product is the more potential consumers are likely to use it. Trust is based on the verification of how good a data product was in the past in keeping its promises. This verification should be automated by the underlying platform and synthetized in a trust score shared with all potential consumers. Example of promises are: description of services' API, SLO, deprecation policy, etc.. Expectations: Through expectations the data product declares how it wants the port to be used by its consumers. Expectations are the inverse of promises. They are a way to explicitly state what promises the data product would like consumers to make regarding how they will use the port. Example of expectations are: intended usage, intended audience, etc.. Contracts: Through contracts the data product declares promises and expectations that must be respected both by itself and its consumers respectively. A contract is an explicit agreement between the data product and its consumers. It is used to group all the promises and expectations that if not respected can generate penalties like monetary sanctions or interruption of service. Example of contracts are: terms of conditions, SLA, billing policy, etc.. The governance can use these concepts to standardize the definition of these interfaces across all data products, while the platform can use them to provide the mechanisms to implement the described services in a compliant way. Data Product Application Components \u2693\ufe0e The components of a data product that implement the services exposed through its ports (i.e. pipelines, microservices, etc..). Data Product Infrastructure Components \u2693\ufe0e The components of a data product related to the infrastructural resources (i.e. storage, compute, etc..) used to run its application components . Data Product Descriptor Document \u2693\ufe0e The document (or set of documents) that contains the standard definition of a data product created using and conforming to the Data Product Descriptor Specification . Data Product Descriptor Specification \u2693\ufe0e The formal description of the rules to follow in order to create a standard compliant Data Product Descriptor Document . Specification \u2693\ufe0e Versions \u2693\ufe0e The Data Product Descriptor Specification is versioned using Semantic Versioning 2.0.0 (semver) and follows the semver specification. The major . minor portion of the semver (for example 1.0 ) SHALL designate the DPDS feature set. Typically, .patch versions address errors in this document, not the feature set. Tooling which supports DPDS 1.0 SHOULD be compatible with all DPDS 1.0.* versions. The patch version SHOULD NOT be considered by tooling, making no distinction between 1.0.0 and 1.0.1 for example. Each new minor version of the Data Product Descriptor Specification SHALL allow any Product Descriptor document that is valid against any previous minor version of the Specification, within the same major version, to be updated to the new Specification version with equivalent semantics. Such an update MUST only require changing the dataProductDescriptor property to the new minor version. For example, a valid Data Product Descriptor 1.0.2 document, upon changing its dataProductDescriptor property to 1.1.0 , SHALL be a valid Data Product Descriptor 1.1.0 document, semantically equivalent to the original Data Product Descriptor 1.0.2 document. New minor versions of the Data Product Descriptor Specification MUST be written to ensure this form of backward compatibility. Format \u2693\ufe0e A Data Product Descriptor Document that conforms to the Data Product Descriptor Specification is itself a JSON object, which may be represented either in JSON or YAML format. For example, if a field has an array value, the JSON array representation will be used: { \"field\" : [ 1 , 2 , 3 ] } All field names in the specification are case sensitive . This includes all fields that are used as keys in a map, except where explicitly noted that keys are case insensitive . The schema exposes two types of fields: Fixed fields, which have a declared name, and Patterned fields, which declare a regex pattern for the field name. Patterned fields MUST have unique names within the containing object. In order to preserve the ability to round-trip between YAML and JSON formats, YAML version 1.2 is RECOMMENDED along with some additional constraints: Tags MUST be limited to those allowed by the JSON Schema ruleset . Keys used in YAML maps MUST be limited to a scalar string, as defined by the YAML Failsafe schema ruleset . Document Structure \u2693\ufe0e A Data Product Descriptor Document MAY be made up of a single document or be divided into multiple, connected parts at the discretion of the user. In the latter case a Reference Objects is used. It is RECOMMENDED that the root Data Product Descriptor Document be named: data-product-descriptor.json or data-product-descriptor.yaml . Object Types \u2693\ufe0e A Data Product Descriptor Document have one and only one root object. The properties of an object are described by its fields. A field type can be another object or a primitive type . An addressable and versioned object is called entity. The root object of the Data Product Descriptor Document is an entity object. Other entities that exist only in the scope of the root entity are called components. Data Types \u2693\ufe0e Primitive data types in the DPDS are based on the types supported by the JSON Schema Specification Wright Draft 00 . Primitives have an optional modifier property: format . DPDS uses several known formats to define in fine detail the data type being used. However, to support documentation needs, the format property is an open string -valued property, and can have any value. Formats such as \"email\" , \"uuid\" , and so on, MAY be used even though undefined by this specification. Types that are not accompanied by a format property follow the type definition in the JSON Schema. Tools that do not recognize a specific format MAY default back to the type alone, as if the format is not specified. The formats defined by the DPDS are: type format Comments integer int32 signed 32 bits integer int64 signed 64 bits (a.k.a long) number float number double string string alphanumeric a string that match the following regex ^[a-zA-Z0-9]+$ string name a string that match the following regex ^[a-zA-Z][a-zA-Z0-9]+$ string fqn a string that match the following regex ^[a-zA-Z][a-zA-Z0-9.:]+$ string version a string that match the following regex ^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$ string byte base64 encoded characters string binary any sequence of octets string uuid a sequence of 16 octets as defined by RFC4122 boolean string date As defined by full-date - RFC3339 string date-time As defined by date-time - RFC3339 string password A hint to UIs to obscure input. Rich Text Formatting \u2693\ufe0e Throughout the specification description fields are noted as supporting CommonMark markdown formatting. Where Data Product Descriptor tooling renders rich text it MUST support, at a minimum, markdown syntax as described by CommonMark 0.27 . Tooling MAY choose to ignore some CommonMark features to address security concerns. Relative References in URLs \u2693\ufe0e Unless specified otherwise, all properties that are URLs SHOULD be absolute references. If a property explicitly specify in its description that allows a relative reference its value MUST be compliant with RFC3986 . Relative references MUST be resolved using the URLs defined in the property description as a Base URI. Relative references used in $ref are processed as per JSON Reference , using the URL of the current document as the base URI. See also the Reference Object . Schema \u2693\ufe0e In the following description, if a field is not explicitly REQUIRED or described with a MUST or SHALL, it can be considered OPTIONAL. Data Product Descriptor Entity \u2693\ufe0e This is the root object of the Data Product Descriptor Document . Fixed Fields \u2693\ufe0e Field Name Type Description dataProductDescriptor string:version (REQUIRED) The semantic version number of the Data Product Descriptor Specification Version that the Data Product Descriptor Document uses. The dataProductDescriptor field SHOULD be used by tooling specifications and clients to interpret the Data Product Descriptor Document . This is not related to the data product version field. id string:uuid (READONLY) It's an UUID version 3 ( RFC-4122 ) generated server side during data product creation as SHA-1 hash of the fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to referentiate the data product. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to referentiate the data product when calling an API different from the ones exposed by the data product experience plane the fullyQualifiedName MUST be always used. Example: \"id: \"2b172838-73b1-5d6c-be45-cc75aee180a0\" fullyQualifiedName string:fqn (REQUIRED) The unique universal idetifier of the data product. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version} . It's RECOMMENDED to use as mesh-namespace your company's domain name in reverse dot notation (es it.quantyca ) in order to ensure that the fullyQualifiedName is unique universal idetifier as REQUIRED. To the mesh-nemaspace MAY be added as postfix the product's 'domain' (es. planning , operations , ...). Using the data product's domain as postfix in the mesh-namespace is anyway NOT RECOMANDED. Example: \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1\" . entityType string:alphanumeric (READONLY) The type of the entity. It MUST be a constant value equals to dataproduct . name string:name (REQUIRED) The name of the data product. MUST be unique within the mesh-namespace . It's RECOMMENDED to use a camel case formatted string. version string:version (REQUIRED) The semantic version number of the data product definition contained in the given Data Product Descriptor Document . Everytime the major version of one of the data product's ports changes also the major version of the product MUST be incremented. It is RECOMANDED to use 0 as major version for data products that are not yet general available. These data products can introduce breaking changes without incrementing their major version . It is anyway RECOMANDED that for every breaking change introduced by a data product that is not yet general available (i.e. major version equals to 0) at least the minor version is incremented. This field is not related to the dataProductDescriptor field. displayName string The human readable name of the data product. It SHOULD be used by frontend tool to visualize data product's name in place of the name property. It's RECOMMENDED to not use the same displayName for different data products belonging to the same mesh-namespace . description string The data product description. CommonMark syntax MAY be used for rich text representation. info Info Object (REQUIRED) Provides metadata about the data product. The metadata can be used by the platform or by consumers if needed. interfaceComponents Interface Components Object A collection of all interface entities exposed by the data product internalComponents Internal Components Object A collection of all internal entities that compose the data product components Components Object An element to hold a set of reusable objects that can be referentiated in other part of the document. tags [ string ] A list of tags associated to the data product. Tags can be used for logical grouping of data products. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Info Object \u2693\ufe0e The Info Object provides metadata about the data product. The metadata can be used by the platform or by consumers if needed. Fixed Fields \u2693\ufe0e Field Name Type Description domain string:name (REQUIRED) The domain to which the data product belongs to. owner Owner Object A collection of information related to the data product's owner. contactPoints [ Contact Point Object ] A collection of contact information for the given data product. This object MAY be extended with Specification Extensions . Owner Object \u2693\ufe0e The Owner Object describes the data product's owner. Fixed Fields \u2693\ufe0e Field Name Type Description id string (REQUIRED) The identifier of the data product's owner. It's RECOMMENDED to use the corporate mail of the owner as identifier. name string The full name of the data product's owner This object MAY be extended with Specification Extensions . Owner Object Example: \u2693\ufe0e { \"id\" : \"john.doe@company-xyz.com\" , \"name\" : \"John Doe\" } Contact Point Object \u2693\ufe0e The Contact Point Object describes a data product's contact point. Fixed Fields \u2693\ufe0e Field Name Type Description name string:name The name of the contact point. description string The contact point description. CommonMark syntax MAY be used for rich text representation. channel string The channel used to address the contact point. It can be for example equal to web , mail or phone . address string The address of the contact point. Depending on the channel it can be for example an URL, an email address or a phone number. This object MAY be extended with Specification Extensions . Contact Point Object Example: \u2693\ufe0e { \"name\" : \"Support Team Mail\" , \"description\" : \"The mail address of to the team that give support on this product\" , \"channel\" : \"email\" , \"address\" : \"trip-execution-support@company-xyz.com\" } { \"name\" : \"Issue Tracker\" , \"description\" : \"The address of the issue tracker associated to this product\" , \"channel\" : \"web\" , \"address\" : \"https://readmine.company-xyz.com/trip-execution\" } Interface Components Object \u2693\ufe0e The Interface Components Object it's a collection of all interface entities exposed by a data product. Fixed Fields \u2693\ufe0e Field Name Type Description inputPorts [ Input Port Component | Reference Object ] The input ports exposed by the data product. outputPorts [ Output Port Component | Reference Object ] (REQUIRED) The output ports exposed by the data product. discoveryPorts [ Discovery Port Component | Reference Object ] The discovery ports exposed by the data product. observabilityPorts [ Observability Port Component | Reference Object ] The observability ports exposed by the data product. controlPorts [ Control Port Component | Reference Object ] The control ports exposed by the data product. This object cannot be extended with additional properties and any properties added SHALL be ignored. Input Port Component \u2693\ufe0e The Input Port Component describes an input port of a data product. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the port's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to referentiate the port. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to referentiate the data product when calling API different from the ones exposed by the data product experience plane the port's fullyQualifiedName MUST be always used. Example: \"id\": \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) . The unique universal idetifier of the port. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:inputports:{port-name} . Example: \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:inputports:tmsTripCDC\" . entityType string:alphanumeric The type of the entity. It MUST be a constant value equals to inputport . name string:name (REQUIRED) The name of the port. It MUST be unique within the other input ports of the same data product. It's RECOMMENDED to use a cammel case formatted string. Example \"name: \"tmsTripCDC\" . version string:version (REQUIRED) The semantic version number of the data product's port. Everytime the major version of port changes also the major version of the product MUST be incremented. displayName string The human readable name of the port. It SHOULD be used by frontend tool to visualize port's name in place of the name property. It's RECOMMENDED to not use the same displayName for different input ports belonging to the same data product. description string The port descripion. CommonMark syntax MAY be used for rich text representation. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. promises Promises Object | Reference Object The data product's promises declared over the port. expectations Expectation Object | Reference Object The data product's expectations declared over the port. contracts Contracts Object | Reference Object The data product's contracts declared over the port. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Output Port Component \u2693\ufe0e The 'Output Port Component' describes an output port of a data product. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the port's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to referentiate the port. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to referentiate the data product when calling API different from the ones exposed by the data product experience plane the port's fullyQualifiedName MUST be always used. Example: \"id\": \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) The unique universal idetifier of the port. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:inputports:{port-name} . Example \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:inputports:tmsTripCDC\" . entityType string:alphanumeric The type of the entity. It MUST be a constant value equals to outputport . name string:name (REQUIRED) The name of the port. MUST be unique within the other input ports of the same data product. It's RECOMMENDED to use a cammel case formatted string. Example \"name: \"tmsTripCDC\" . version string:version (REQUIRED) The semantic version number of the data product's port. Everytime the major version of port changes also the major version of the product MUST be incremented. displayName string The human readable name of the port. It SHOULD be used by frontend tool to visualize port's name in place of the name property. It's RECOMMENDED to not use the same displayName for different input ports belonging to the same data product. description string The port descripion. CommonMark syntax MAY be used for rich text representation. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. promises Promises Object | Reference Object The data product's promises declared over the port. expectations Expectation Object | Reference Object The data product's expectations declared over the port. contracts Contracts Object | Reference Object The data product's contracts declared over the port. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Discovey Port Component \u2693\ufe0e The Discovey Port Component describes a discovery port of a data product. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the port's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to referentiate the port. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to referentiate the data product when calling API different from the ones exposed by the data product experience plane the port's fullyQualified name MUST be always used. \"id: \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) . The unique universal idetifier of the port. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:inputports:{port-name} . Example \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:inputports:tmsTripCDC\" . entityType string:alphanumeric The type of the entity. It MUST be a constant value equals to discoveryport . name string:name (REQUIRED) The name of the port. MUST be unique within the other input ports of the same data product. It's RECOMMENDED to use a cammel case formatted string. Example \"name: \"tmsTripCDC\" . version string:version (REQUIRED) The semantic version number of the data product's port. Everytime the major version of port changes also the major version of the product MUST be incremented. displayName string The human readable name of the port. It SHOULD be used by frontend tool to visualize port's name in place of the name property. It's RECOMMENDED to not use the same displayName for different input ports belonging to the same data product. description string The port descripion. CommonMark syntax MAY be used for rich text representation. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. promises Promises Object | Reference Object The data product's promises declared over the port. expectations Expectation Object | Reference Object The data product's expectations declared over the port. contracts Contracts Object | Reference Object The data product's contracts declared over the port. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Observability Port Component \u2693\ufe0e The Observability Port Component describes an observability port of a data product. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the port's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to referentiate the port. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to referentiate the data product when calling API different from the ones exposed by the data product experience plane the port's fullyQualified name MUST be always used. \"id: \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) The unique universal idetifier of the port. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:inputports:{port-name} . Example \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:inputports:tmsTripCDC\" . entityType string:alphanumeric The type of the entity. It MUST be a constant value equals to observabilityport . name string:name (REQUIRED) The name of the port. MUST be unique within the other input ports of the same data product. It's RECOMMENDED to use a cammel case formatted string. Example \"name: \"tmsTripCDC\" . version string:version (REQUIRED) The semantic version number of the data product's port. Everytime the major version of port changes also the major version of the product MUST be incremented. displayName string The human readable name of the port. It SHOULD be used by frontend tool to visualize port's name in place of the name property. It's RECOMMENDED to not use the same displayName for different input ports belonging to the same data product. description string The port descripion. CommonMark syntax MAY be used for rich text representation. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. promises Promises Object | Reference Object The data product's promises declared over the port. expectations Expectation Object | Reference Object The data product's expectations declared over the port. contracts Contracts Object | Reference Object The data product's contracts declared over the port. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Control Port Component \u2693\ufe0e The Control Port Component describes a control port of a data product. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the port's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to referentiate the port. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to referentiate the data product when calling API different from the ones exposed by the data product experience plane the port's fullyQualified name MUST be always used. \"id: \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) . The unique universal idetifier of the port. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:inputports:{port-name} . Example \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:inputports:tmsTripCDC\" . entityType string:alphanumeric The type of the entity. It MUST be a constant value equals to controlport . name string:name (REQUIRED) The name of the port. MUST be unique within the other input ports of the same data product. It's RECOMMENDED to use a cammel case formatted string. Example \"name: \"tmsTripCDC\" . version string:version (REQUIRED) The semantic version number of the data product's port. Everytime the major version of port changes also the major version of the product MUST be incremented. displayName string The human readable name of the port. It SHOULD be used by frontend tool to visualize port's name in place of the name property. It's RECOMMENDED to not use the same displayName for different input ports belonging to the same data product. description string The port descripion. CommonMark syntax MAY be used for rich text representation. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. promises Promises Object | Reference Object The data product's promises declared over the port. expectations Expectation Object | Reference Object The data product's expectations declared over the port. contracts Contracts Object | Reference Object The data product's contracts declared over the port. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Promises Object \u2693\ufe0e The Promises Object describes the data product's promises declared over a given port. Fixed Fields \u2693\ufe0e Field Name Type Description platform string The target technological platform in which the services associated with the given port operate. It contains usually the infrastructure provider and data center location. Optionally it can contains also the specific runtime technology used. Examples: onprem:milan-1 , aws:eu-south-1 , aws:eu-south-1:redshift . servicesType string The type of services associated with the given port. Examples: soap-services , rest-services , odata-services , streaming-services , datastore-services . api Standard Definition Object The formal description of port's services API. It is RECOMMENDED to use Open API Specification for restfull services, Async API Specification for streaming services and DataStore API Specification for data store connection based services. Other specifications MAY be used as required. depreceationPolicy Specification Extension Point Object The deprecation policy adopted by the port. It is RECOMMENDED to specify at least how long the deprecation period will be after the release of a new major version. slo Specification Extension Point The service level objectives supported by the port. It is RECOMMENDED to group SLO by category (ex. operational SLO, quality SLO, etc ...) and specify them in an easy to compute way. This object MAY be extended with Specification Extensions . Expectations Object \u2693\ufe0e The Expectations Object describes the data product's expectations declared over a given port. Fixed Fields \u2693\ufe0e Field Name Type Description audience Specification Extension Point Object The audience of consumers for whom the the port has been designed. It is RECOMMENDED to specify inclusion and exclusion criteria in a way that is not ambiguous. usage Specification Extension Point The usage patterns for which the port has been designed. This object MAY be extended with Specification Extensions . Contracts Object \u2693\ufe0e The Contracts Object describes the data product's contracts declared over a given port. Fixed Fields \u2693\ufe0e Field Name Type Description termsAndConditions Specification Extension Point Object The terms and conditions defined on the port on which consumers must agree on and respect in order to use it. billingPolicy Specification Extension Point The billing policy defined on the port on which consumers must agree on and respect in order to use it. sla Specification Extension Point The service level agreements supported by the port. It is RECOMMENDED to group SLA by category (ex. operational SLA, quality SLA, ecc ...) and specify them in an easy to compute way. This object MAY be extended with Specification Extensions . Internal Components Object \u2693\ufe0e The Internal Components Object it's a collection of all internal entities that compose a data product. Fixed Fields \u2693\ufe0e Field Name Type Description applicationComponents [ Application Component ] The list of application component that compose the data product. infrastructuralComponents [ Infrastructural Component ] The list of infrastructure components that compose the data product. This object cannot be extended with additional properties and any properties added SHALL be ignored. Application Component \u2693\ufe0e The Application Component describes an internal application component used by the data product to provide services through its ports. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the component's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to address the component. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to address the component when calling API different from the ones exposed by the data product experience plane the component's fullyQualifiedName MUST be always used. Examples: \"id: \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) . The unique universal idetifier of the component. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:applications:{app-name} . Example \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:applications:modelNormalizationJob\" . entityType string:alphanumeric (READONLY) The type of the entity. It is a constant value equals to application . name string:name The name of the application component. MUST be unique within the other application components of the same data product. It's RECOMMENDED to use a camel case formatted string. Example \"name: \"modelNormalizationJob\" . version string:version (REQUIRED) The semantic version number of the data product's application component. displayName string The human readable name of the component. It SHOULD be used by frontend tool to visualize application component's name in place of the name property. It's RECOMMENDED to not use the same displayName for different application component belonging to the same data product. description string The application component description. CommonMark syntax MAY be used for rich text representation. platform string The target technological platform on which the application will be deployed. It contains usually the infrastructure provider and data center location. Optionally it can contains also the specific runtime technology used. Examples: onprem:milan-1 , aws:eu-south-1 , aws:eu-south-1:redshift . applicationType string The type of the application: Examples: stream-sourcing , batch-sourcing , streaming-transformation , batch-transformation , housekeeping , ecc... buildServiceName string:name | External Resource Object The logical name or the actual endpoint of the service to call in order to build the application component. If the logical name is used as field value the actual endpoint value resulution is demanded to the data product experience plane of the underlyng platform. buildTemplate object | Reference Object | External Resource Object Can be an inline json or a refernce to an external resource. It contains the definition of the pipeline to execute in order to build the application. It is passed as is to the build service specified using the buildServiceUrl or the buildServiceName field. buildConfigurations object | Reference Object | External Resource Object Can be an inline json or a refernce to an external resource. It contains the configuration properties that can be used by the build service at build time. It is passed as is to the build service specified using the buildServiceUrl or the buildServiceName field. deployServiceName string:name | External Resource Object The logical name or the actual endpoint of the service to call in order to deploy the application component. If the logical name is used as field value the actual endpoint value resulution is demanded to the data product experience plane of the underlyng platform. deployTemplate object | Reference Object | External Resource Object Can be an inline json or a refernce to an external resource. It contains the definition of the pipeline to execute in order to deploy the application. It is passed as is to the deploy service specified using the deployServiceUrl or the deployServiceName field. deployConfigurations object | Reference Object | External Resource Object Can be an inline json or a refernce to an external resource. It contains the configuration properties that can be used by the deploy service at deploy time. It is passed as is to the deploy service specified using the deployServiceUrl or the deployServiceName field. consumeFrom [ string:fqn ] The list of ports or infrastructural components from which the application consumes directly data or services. provideTo [ string:fqn ] The list of ports or infrastructural components to which the application provides directly data or services. dependsOn [ string:fqn ] A list of other internal components on which this application directly depends on. It is used during data product deployment to define a consistent deployment plan. Cyclic dependencies between components MUST be avoided. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Infrastructure Component \u2693\ufe0e The Infrastructural Component describes an internal infrastructural component used by the data product to run its applications and store its data. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the component's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to address the component. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to address the component when calling API different from the ones exposed by the data product experience plane the component's fullyQualifiedName MUST be always used. Examples: \"id: \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) . The unique universal idetifier of the component. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:infrastructure:{infra-name} . Example \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:infrastructure:stagingArea\" . entityType string:alphanumeric (READONLY) The type of the entity. It is a constant value equals to infrastructure . name string:name The name of the infrastructural component. MUST be unique within the other infrastructural components of the same data product. It's RECOMMENDED to use a camel case formatted string. Example \"name: \"stagingArea\" . version string:version (REQUIRED) The semantic version number of the data product's infrastructural component. displayName string The human readable name of the component. It SHOULD be used by frontend tool to visualize application component's name in place of the name property. It's RECOMMENDED to not use the same displayName for different infrastructural component belonging to the same data product. description string The infrastructural component descripion. CommonMark syntax MAY be used for rich text representation. platform string The target technological platform on which the infrastructure component will be provisioned. It contains usually the infrastructure provider and data center location. Optionally it can contains also the specific resource object that will be provisioned. Examples: onprem:milan-1 , aws:eu-south-1 , aws:eu-south-1:s3-buket . infrastructureType string The type of the infrastructural component. Examples: computation-resource , storage-resource , networking-resource , ecc... provisionService string:name | External Resource Object The logical name or the actual endpoint of the service to call in order to provision the infrastructural component. If the logical name is used as field value the actual endpoint value resulution is demanded to the data product experience plane of the underlyng platform. provisionTemplate object | Reference Object | External Resource Object Can be an inline json or a refernce to an external resource. It contains the definition of the resources to provision. It is passed as is to the provision service specified using the provisionServiceUrl or the provisionServiceName field. provisionConfigurations object | Reference Object | External Resource Object Can be an inline json or a refernce to an external resource. It contains the configuration properties that can be used by the provision service at provision time. It is passed as is to the provision service specified using the provisionServiceUrl or the provisionServiceName field. dependsOn [ string:fqn ] A list of other infrastructural components on which this component directly depends on. It is used during infrastructure provisioning to define a consistent provisioning plan. Cyclic dependencies between infrastructural components MUST be avoided. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. Components Object \u2693\ufe0e The Components Object holds a set of reusable objects for different aspects of the DPDS. All objects defined within the components object will have no effect on the Data Product Descriptor unless they are explicitly referenced from properties outside the components object. Fixed Fields \u2693\ufe0e Field Name Type Description inputPorts Map[ string , Input Port Component | Reference Object ] An object to hold reusable Input Port Component . outputPorts Map[ string , Output Port Component | Reference Object ] An object to hold reusable Output Port Component . discoveryPorts Map[ string , Discovery Port Component | Reference Object ] An object to hold reusable Discovery Port Component . observabilityPorts Map[ string , Observability Port Component | Reference Object ] An object to hold reusable Observability Port Component . controlPorts Map[ string , Control Port Component | Reference Object ] An object to hold reusable Control Port Component . applicationComponents Map[ string , Application Component | Reference Object ] An object to hold reusable Application Component . infrastructuralComponents Map[ string , Infrastructural Component | Reference Object ] An object to hold reusable Infrastructural Component . This object MAY be extended with Specification Extensions . All the fixed fields declared above are objects that MUST use keys that match the regular expression: ^[a-zA-Z0-9\\.\\-_]+$ . Reference Object \u2693\ufe0e The Reference Object allows referencing other components in the Data Product Descriptor Document , internally and externally. The $ref string value contains a URI RFC3986 , which identifies the location of the value being referenced. See the rules for resolving Relative References . Fixed Fields \u2693\ufe0e Field Name Type Description description string A description which by default SHOULD override that of the referenced component. CommonMark syntax MAY be used for rich text representation. If the referenced object-type does not allow a description field, then this field has no effect. $ref string REQUIRED . The reference identifier. This MUST be in the form of a URI. This object cannot be extended with additional properties and any properties added SHALL be ignored. Reference Object Example \u2693\ufe0e { \"$ref\" : \"#/components/schemas/Pet\" } Relative Schema Document Example \u2693\ufe0e { \"$ref\" : \"Pet.json\" } Relative Documents With Embedded Schema Example \u2693\ufe0e { \"$ref\" : \"definitions.json#/Pet\" } External Resource Object \u2693\ufe0e The External Resource Object allows referencing an external resource like a documentation page or a standard definition. Fixed Fields \u2693\ufe0e Field Name Type Description description string A description of the target resource. CommonMark syntax MAY be used for rich text representation. mediaType string The media type of target resource. It must conform to media type format, according to RFC6838 . $href string:uri REQUIRED . The URI of the target resource. It must conform to the URI format, according to RFC3986 . This object cannot be extended with additional properties and any properties added SHALL be ignored. External Resource Object Example \u2693\ufe0e { \"description\" : \"Find more info here\" , \"mediaType\" : \"text/html\" , \"$href\" : \"https://example.com\" } Standard Definition Object \u2693\ufe0e The Standard Definition Object formally describes an object (ex. API object, provision template object, ecc ...) of interest following a given standard specification. Fixed Fields \u2693\ufe0e Field Name Type Description description string The standard definition descripion. CommonMark syntax MAY be used for rich text representation. specification string (REQUIRED) The external specification used in the definition . version string The version of the external specification used in the definition . If not defined the version MUST be included in the definition itself. definition object | Reference Object | External Resource Object (REQUIRED) The formal definition built using the spcification declared in the [specification](#standardDefinitionSpecification) field. externalDocs External Resource Object Additional external documentation for the standard definition. This object MAY be extended with Specification Extensions . Standard Definition Object Example: \u2693\ufe0e { \"description\" : \"The API exposed by the Observability Port that exposes data product logs\" , \"specification\" : \"openapi\" , \"version\" : \"3.1.0\" , \"definition\" : { \"mediaType\" : \"text/json\" , \"$href\" : \"https://mycompany.com/api/v1/planes/utility/logging-services/openapi.json\" }, \"externalDocs\" : { \"mediaType\" : \"text/html\" , \"$href\" : \"https://spec.openapis.org/oas/v3.1.0\" } } Specification Extension Point \u2693\ufe0e A Specification Extension Point marks specific part of the Data Product Descriptor Specification that are left open to extensions or futher evolution of the standard. While a Standard Definition it's a formal declaration that the description of a part of the Data Product Descriptor Specification will be demanded to an external standards in this verion of the specification and in the future ones, the same assumption it's not true for Specification Extension Point . Even if a Specification Extension Point can be extended at will it is RECOMMENDED to use for all added properties a field name prefixed by \"x-\" in order to avoid potetntial conflicts with future versions of the Data Product Descriptor Specification . Fixed Fields \u2693\ufe0e Field Name Type Description description string The extention point descripion. CommonMark syntax MAY be used for rich text representation. externalDocs External Resource Object Additional external documentation for the extention point This object MAY be extended with Specification Extensions . Specification Extensions \u2693\ufe0e While the Data Product Descriptor Specification tries to accommodate most use cases, additional data can be added to extend the specification at certain points. The extensions properties are implemented as patterned fields that are always prefixed by \"x-\" . Field Pattern Type Description ^x- Any Allows extensions to the Data Product Descriptor Schema. The field name MUST begin with x- , for example, x-internal-id . The value can be null , a primitive, an array or an object. Can have any valid JSON format value. The extensions may or may not be supported by the available tooling, but those may be extended as well to add requested support (if tools are internal or open-sourced). Appendix A: Revision History \u2693\ufe0e Version Date Notes 1.0.0 2022-11-01 Release of the Data Product Descriptor Specification 1.0.0","title":"1.0.0."},{"location":"references/schemas/2.0.0/#data-product-descriptor-specification","text":"","title":"Data Product Descriptor Specification"},{"location":"references/schemas/2.0.0/#version-200","text":"The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 RFC2119 RFC8174 when, and only when, they appear in all capitals, as shown here. This document is licensed under The Apache License, Version 2.0 .","title":"Version 2.0.0"},{"location":"references/schemas/2.0.0/#disclaimer","text":"Part of this content has been taken from the great work done by the folks at the OpenAPI Initiative and AsyncAPI Initiative . We have decided to not reinvent the wheel and inspire our work to these two specifications mainly for the following reasons: We think that the work made by OpenAPI Initiative and AsyncAPI Initiative is great :) We want to make the learning curve for the Data Product Descriptor Specification as smooth as possible, aligning its definition to the one of other two popular specifications in the software and data engineers community We think that OpenAPI and AsyncAPI are natural specifications for defining the interface of data product's ports that expose an API endpoint. This specification do not impose to use any specific standard for port's interface definition but these two are highly recommended.","title":"Disclaimer"},{"location":"references/schemas/2.0.0/#introduction","text":"The Data Product Descriptor Specification (DPDS) defines a declarative and technology independent standard to describe a data product in all its components. It allows human agents (e.g. analysts, data scientists, etc..) and digital agents (e.g. other data products, BI tools, planes of the underlying data mesh ops platform, etc..) to operate, discover and access a data product. When properly defined, an external agent can understand and interact with the data product with a minimal amount of cognitive load and implementation logic. The formalization of a standard data product descriptor document through an open specification is useful to enable the implementation of an ecosystem of interoperable data mesh tools. The following is a non exhaustive list of tools that can benefit from the specification: catalogs (search, document and collaborate) design tools (create new products by composition of reusable templates) lifecycle management tools (deploy and operate) access management tools (assign/track access grants and generate client code in different languages) policies checking tools (enforce standard compliance and audit security) observability tools (monitor and detect) data lineage tools (trace data flows and perform forward/backward analysis) mesh topology analysis tools (calculate value/trust scores and detect structural problems) semantic tools (apply ontologies over mesh topology) domain specific language tools (create a collection af interconnected data products that implement together a specific value stream)","title":"Introduction"},{"location":"references/schemas/2.0.0/#table-of-contents","text":"Definitions Standard Standard Specification Standard Definition Data Product Data Product Ports Data Product Application Components Data Product Infrastructure Components Data Product Descriptor Document Data Product Descriptor Specification Specification Versions Format Document Structure Data Types Rich Text Formatting Relative References In URLs Schema Data Product Descriptor Entity Info Object Owner Object Contact Point Object Interface Components Object Input Port Component Output Port Component Discovery Port Component Observability Port Component Control Port Component Promises Object Expectations Object Contracts Object Internal Components Object Application Component Infrastructural Component Components Object Reference Object External Resource Object Standard Definition Object Specification Extension Point Specification Extensions Appendix A: Revision History","title":"Table of Contents"},{"location":"references/schemas/2.0.0/#definitions","text":"","title":"Definitions"},{"location":"references/schemas/2.0.0/#specification","text":"","title":"Specification"},{"location":"references/schemas/2.0.0/#versions","text":"The Data Product Descriptor Specification is versioned using Semantic Versioning 2.0.0 (semver) and follows the semver specification. The major . minor portion of the semver (for example 1.0 ) SHALL designate the DPDS feature set. Typically, .patch versions address errors in this document, not the feature set. Tooling which supports DPDS 1.0 SHOULD be compatible with all DPDS 1.0.* versions. The patch version SHOULD NOT be considered by tooling, making no distinction between 1.0.0 and 1.0.1 for example. Each new minor version of the Data Product Descriptor Specification SHALL allow any Product Descriptor document that is valid against any previous minor version of the Specification, within the same major version, to be updated to the new Specification version with equivalent semantics. Such an update MUST only require changing the dataProductDescriptor property to the new minor version. For example, a valid Data Product Descriptor 1.0.2 document, upon changing its dataProductDescriptor property to 1.1.0 , SHALL be a valid Data Product Descriptor 1.1.0 document, semantically equivalent to the original Data Product Descriptor 1.0.2 document. New minor versions of the Data Product Descriptor Specification MUST be written to ensure this form of backward compatibility.","title":" Versions"},{"location":"references/schemas/2.0.0/#format","text":"A Data Product Descriptor Document that conforms to the Data Product Descriptor Specification is itself a JSON object, which may be represented either in JSON or YAML format. For example, if a field has an array value, the JSON array representation will be used: { \"field\" : [ 1 , 2 , 3 ] } All field names in the specification are case sensitive . This includes all fields that are used as keys in a map, except where explicitly noted that keys are case insensitive . The schema exposes two types of fields: Fixed fields, which have a declared name, and Patterned fields, which declare a regex pattern for the field name. Patterned fields MUST have unique names within the containing object. In order to preserve the ability to round-trip between YAML and JSON formats, YAML version 1.2 is RECOMMENDED along with some additional constraints: Tags MUST be limited to those allowed by the JSON Schema ruleset . Keys used in YAML maps MUST be limited to a scalar string, as defined by the YAML Failsafe schema ruleset .","title":" Format"},{"location":"references/schemas/2.0.0/#document-structure","text":"A Data Product Descriptor Document MAY be made up of a single document or be divided into multiple, connected parts at the discretion of the user. In the latter case a Reference Objects is used. It is RECOMMENDED that the root Data Product Descriptor Document be named: data-product-descriptor.json or data-product-descriptor.yaml .","title":"Document Structure"},{"location":"references/schemas/2.0.0/#object-types","text":"A Data Product Descriptor Document have one and only one root object. The properties of an object are described by its fields. A field type can be another object or a primitive type . An addressable and versioned object is called entity. The root object of the Data Product Descriptor Document is an entity object. Other entities that exist only in the scope of the root entity are called components.","title":"Object Types"},{"location":"references/schemas/2.0.0/#data-types","text":"Primitive data types in the DPDS are based on the types supported by the JSON Schema Specification Wright Draft 00 . Primitives have an optional modifier property: format . DPDS uses several known formats to define in fine detail the data type being used. However, to support documentation needs, the format property is an open string -valued property, and can have any value. Formats such as \"email\" , \"uuid\" , and so on, MAY be used even though undefined by this specification. Types that are not accompanied by a format property follow the type definition in the JSON Schema. Tools that do not recognize a specific format MAY default back to the type alone, as if the format is not specified. The formats defined by the DPDS are: type format Comments integer int32 signed 32 bits integer int64 signed 64 bits (a.k.a long) number float number double string string alphanumeric a string that match the following regex ^[a-zA-Z0-9]+$ string name a string that match the following regex ^[a-zA-Z][a-zA-Z0-9]+$ string fqn a string that match the following regex ^[a-zA-Z][a-zA-Z0-9.:]+$ string version a string that match the following regex ^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$ string byte base64 encoded characters string binary any sequence of octets string uuid a sequence of 16 octets as defined by RFC4122 boolean string date As defined by full-date - RFC3339 string date-time As defined by date-time - RFC3339 string password A hint to UIs to obscure input.","title":"Data Types"},{"location":"references/schemas/2.0.0/#rich-text-formatting","text":"Throughout the specification description fields are noted as supporting CommonMark markdown formatting. Where Data Product Descriptor tooling renders rich text it MUST support, at a minimum, markdown syntax as described by CommonMark 0.27 . Tooling MAY choose to ignore some CommonMark features to address security concerns.","title":"Rich Text Formatting"},{"location":"references/schemas/2.0.0/#relative-references-in-urls","text":"Unless specified otherwise, all properties that are URLs SHOULD be absolute references. If a property explicitly specify in its description that allows a relative reference its value MUST be compliant with RFC3986 . Relative references MUST be resolved using the URLs defined in the property description as a Base URI. Relative references used in $ref are processed as per JSON Reference , using the URL of the current document as the base URI. See also the Reference Object .","title":"Relative References in URLs"},{"location":"references/schemas/2.0.0/#schema","text":"In the following description, if a field is not explicitly REQUIRED or described with a MUST or SHALL, it can be considered OPTIONAL.","title":"Schema"},{"location":"references/schemas/2.0.0/#data-product-descriptor-entity","text":"This is the root object of the Data Product Descriptor Document .","title":"Data Product Descriptor Entity"},{"location":"references/schemas/2.0.0/#info-object","text":"The Info Object provides metadata about the data product. The metadata can be used by the platform or by consumers if needed.","title":"Info Object"},{"location":"references/schemas/2.0.0/#owner-object","text":"The Owner Object describes the data product's owner.","title":"Owner Object"},{"location":"references/schemas/2.0.0/#contact-point-object","text":"The Contact Point Object describes a data product's contact point.","title":"Contact Point Object"},{"location":"references/schemas/2.0.0/#interface-components-object","text":"The Interface Components Object it's a collection of all interface entities exposed by a data product.","title":"Interface Components Object"},{"location":"references/schemas/2.0.0/#input-port-component","text":"The Input Port Component describes an input port of a data product.","title":"Input Port Component"},{"location":"references/schemas/2.0.0/#output-port-component","text":"The 'Output Port Component' describes an output port of a data product.","title":"Output Port Component"},{"location":"references/schemas/2.0.0/#discovey-port-component","text":"The Discovey Port Component describes a discovery port of a data product.","title":"Discovey Port Component"},{"location":"references/schemas/2.0.0/#observability-port-component","text":"The Observability Port Component describes an observability port of a data product.","title":"Observability Port Component"},{"location":"references/schemas/2.0.0/#control-port-component","text":"The Control Port Component describes a control port of a data product.","title":"Control Port Component"},{"location":"references/schemas/2.0.0/#promises-object","text":"The Promises Object describes the data product's promises declared over a given port.","title":"Promises Object"},{"location":"references/schemas/2.0.0/#expectations-object","text":"The Expectations Object describes the data product's expectations declared over a given port.","title":"Expectations Object"},{"location":"references/schemas/2.0.0/#contracts-object","text":"The Contracts Object describes the data product's contracts declared over a given port.","title":"Contracts Object"},{"location":"references/schemas/2.0.0/#internal-components-object","text":"The Internal Components Object it's a collection of all internal entities that compose a data product.","title":"Internal Components Object"},{"location":"references/schemas/2.0.0/#application-component","text":"The Application Component describes an internal application component used by the data product to provide services through its ports.","title":"Application Component"},{"location":"references/schemas/2.0.0/#infrastructure-component","text":"The Infrastructural Component describes an internal infrastructural component used by the data product to run its applications and store its data.","title":"Infrastructure Component"},{"location":"references/schemas/2.0.0/#components-object","text":"The Components Object holds a set of reusable objects for different aspects of the DPDS. All objects defined within the components object will have no effect on the Data Product Descriptor unless they are explicitly referenced from properties outside the components object.","title":"Components Object"},{"location":"references/schemas/2.0.0/#reference-object","text":"The Reference Object allows referencing other components in the Data Product Descriptor Document , internally and externally. The $ref string value contains a URI RFC3986 , which identifies the location of the value being referenced. See the rules for resolving Relative References .","title":"Reference Object"},{"location":"references/schemas/2.0.0/#external-resource-object","text":"The External Resource Object allows referencing an external resource like a documentation page or a standard definition.","title":"External Resource Object"},{"location":"references/schemas/2.0.0/#standard-definition-object","text":"The Standard Definition Object formally describes an object (ex. API object, provision template object, ecc ...) of interest following a given standard specification.","title":"Standard Definition Object"},{"location":"references/schemas/2.0.0/#specification-extension-point","text":"A Specification Extension Point marks specific part of the Data Product Descriptor Specification that are left open to extensions or futher evolution of the standard. While a Standard Definition it's a formal declaration that the description of a part of the Data Product Descriptor Specification will be demanded to an external standards in this verion of the specification and in the future ones, the same assumption it's not true for Specification Extension Point . Even if a Specification Extension Point can be extended at will it is RECOMMENDED to use for all added properties a field name prefixed by \"x-\" in order to avoid potetntial conflicts with future versions of the Data Product Descriptor Specification .","title":"Specification Extension Point"},{"location":"references/schemas/2.0.0/#specification-extensions","text":"While the Data Product Descriptor Specification tries to accommodate most use cases, additional data can be added to extend the specification at certain points. The extensions properties are implemented as patterned fields that are always prefixed by \"x-\" . Field Pattern Type Description ^x- Any Allows extensions to the Data Product Descriptor Schema. The field name MUST begin with x- , for example, x-internal-id . The value can be null , a primitive, an array or an object. Can have any valid JSON format value. The extensions may or may not be supported by the available tooling, but those may be extended as well to add requested support (if tools are internal or open-sourced).","title":"Specification Extensions"},{"location":"references/schemas/2.0.0/#appendix-a-revision-history","text":"Version Date Notes 1.0.0 2022-11-01 Release of the Data Product Descriptor Specification 1.0.0","title":"Appendix A: Revision History"},{"location":"references/specifications/","text":"Specification Versions \u2693\ufe0e TODO DPDS v1.0.0","title":"Versions"},{"location":"references/specifications/#specification-versions","text":"TODO DPDS v1.0.0","title":"Specification Versions"},{"location":"references/specifications/1.0.0/","text":"Data Product Descriptor Specification \u2693\ufe0e Version 1.0.0 \u2693\ufe0e The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 RFC2119 RFC8174 when, and only when, they appear in all capitals, as shown here. This document is licensed under The Apache License, Version 2.0 . Disclaimer \u2693\ufe0e Part of this content has been taken from the great work done by the folks at the OpenAPI Initiative and AsyncAPI Initiative . We have decided to not reinvent the wheel and inspire our work to these two specifications mainly for the following reasons: We think that the work made by OpenAPI Initiative and AsyncAPI Initiative is great :) We want to make the learning curve for the Data Product Descriptor Specification as smooth as possible, aligning its definition to the one of other two popular specifications in the software and data engineers community We think that OpenAPI and AsyncAPI are natural specifications for defining the interface of data product's ports that expose an API endpoint. This specification do not impose to use any specific standard for port's interface definition but these two are highly recommended. Introduction \u2693\ufe0e The Data Product Descriptor Specification (DPDS) defines a declarative and technology independent standard to describe a data product in all its components. It allows human agents (e.g. analysts, data scientists, etc..) and digital agents (e.g. other data products, BI tools, planes of the underlying data mesh ops platform, etc..) to operate, discover and access a data product. When properly defined, an external agent can understand and interact with the data product with a minimal amount of cognitive load and implementation logic. The formalization of a standard data product descriptor document through an open specification is useful to enable the implementation of an ecosystem of interoperable data mesh tools. The following is a non exhaustive list of tools that can benefit from the specification: catalogs (search, document and collaborate) design tools (create new products by composition of reusable templates) lifecycle management tools (deploy and operate) access management tools (assign/track access grants and generate client code in different languages) policies checking tools (enforce standard compliance and audit security) observability tools (monitor and detect) data lineage tools (trace data flows and perform forward/backward analysis) mesh topology analysis tools (calculate value/trust scores and detect structural problems) semantic tools (apply ontologies over mesh topology) domain specific language tools (create a collection af interconnected data products that implement together a specific value stream) Table of Contents \u2693\ufe0e Definitions Standard Standard Specification Standard Definition Data Product Data Product Ports Data Product Application Components Data Product Infrastructural Components Data Product Descriptor Document Data Product Descriptor Specification Specification Versions Format Document Structure Data Types Rich Text Formatting Relative References In URLs Schema Data Product Descriptor Entity Info Object Owner Object Contact Point Object Interface Components Object Input Port Component Output Port Component Discovery Port Component Observability Port Component Control Port Component Promises Object Expectations Object Contracts Object Internal Components Object Application Component Build Info Object Deploy Info Object Infrastructural Component Provision Info Object Components Object Reference Object External Resource Object Standard Definition Object Specification Extension Point Specification Extensions Appendix A: Revision History Definitions \u2693\ufe0e Standard \u2693\ufe0e The set of shared rules used by different agents to describe an entity or process of common interest. The agents that follow the standard limit their autonomy conforming to the set of shared rules in order to facilitate cooperation between them through interoperability. Standard Specification \u2693\ufe0e The formal description of the rules that form a standard . A standard can have multiple specification versions associated to it. Sometime the words standard and specification are used as synonymous. Standard Definition \u2693\ufe0e The description of one specific entity or process created using and conforming to the set of rules formally described in the standard specification Data Product \u2693\ufe0e The smallest unit that can be independently deployed and managed in a data architecture (i.e. architectural quantum). It is composed by all the structural components that it requires to do its function: metadata, data, code, policies that govern the data and its dependencies to infrastructure. Each data product has a clear identifier, a version number and an owner. Data Product Ports \u2693\ufe0e The interfaces exposed to external agents by a data product . Each port expose a service or set of correlated services. These are the five types of port supported by a data product : Input port(s): an input port describes a set of services exposed by a data product to collect its source data and makes it available for further internal transformation. An input port can receive data from one ore more upstream sources in a push (i.e. asynchronous subscription) or pop mode (i.e. synchronous query). Each data product may have one or more input ports. Output port(s): an output port describes a set of services exposed by a data product to share the generated data in a way that can be understood and trusted. Each data product may have one or more output ports. Discovery port(s): a discovery port describes a set of services exposed by a data product to provide information about its static role in the overall architecture like purpose, structure, location, etc.. Each data product may have one or multiple discovery ports. Observability port(s): an observability port describes a set of services exposed by a data product to provide information about its dynamic behaviour in the overall architecture like logs, traces, audit trails, metrics, etc.. Each data product may have one or more observability ports. Control port(s): a control port describes a set of services exposed by a data product to configure local policies or perform highly privileged governance operations. Each data product may have one or more control ports. The data product descriptor specification uses the following concepts of promises theory to formally describe the set of services exposed by each port regardless of the specific type: Promises: Through promises the data product declares the intent of the port. Promises are not a guarantee of the outcome but the data product will behave accordingly to them in order to realize its intent. The more a data product keeps its promises over time and the more trustworthy it is. Thus, the more trustworthy a data product is the more potential consumers are likely to use it. Trust is based on the verification of how good a data product was in the past in keeping its promises. This verification should be automated by the underlying platform and synthetized in a trust score shared with all potential consumers. Example of promises are: description of services' API, SLO, deprecation policy, etc.. Expectations: Through expectations the data product declares how it wants the port to be used by its consumers. Expectations are the inverse of promises. They are a way to explicitly state what promises the data product would like consumers to make regarding how they will use the port. Example of expectations are: intended usage, intended audience, etc.. Contracts: Through contracts the data product declares promises and expectations that must be respected by the data product and its consumers. A contract is an explicit agreement between the data product and its consumers. It is used to group all the promises and expectations that if not respected can generate penalties like monetary sanctions or interruption of service. Example of contracts are: terms of conditions, SLA, billing policy, etc.. The governance can use these concepts to standardize the definition of these interfaces across all data products, while the platform can use them to provide the mechanisms to implement the described services in a compliant way. Data Product Application Components \u2693\ufe0e The components of a data product that implement the services exposed through its ports (i.e. pipelines, microservices, etc..). Data Product Infrastructural Components \u2693\ufe0e The components of a data product related to the infrastructural resources (i.e. storage, compute, etc..) used to run its application components . Data Product Descriptor Document \u2693\ufe0e The document (or set of documents) that contains the standard definition of a data product created using and conforming to the Data Product Descriptor Specification . Data Product Descriptor Specification \u2693\ufe0e The formal description of the rules to follow in order to create a standard compliant Data Product Descriptor Document . Specification \u2693\ufe0e Versions \u2693\ufe0e The Data Product Descriptor Specification is versioned using Semantic Versioning 2.0.0 (semver) and follows the semver specification. The major . minor portion of the semver (for example 1.0 ) SHALL designate the DPDS feature set. Typically, .patch versions address errors in this document, not the feature set. Tooling which supports DPDS 1.0 SHOULD be compatible with all DPDS 1.0.* versions. The patch version SHOULD NOT be considered by tooling, making no distinction between 1.0.0 and 1.0.1 for example. Each new minor version of the Data Product Descriptor Specification SHALL allow any Product Descriptor document that is valid against any previous minor version of the Specification, within the same major version, to be updated to the new Specification version with equivalent semantics. Such an update MUST only require changing the dataProductDescriptor property to the new minor version. For example, a valid Data Product Descriptor 1.0.2 document, upon changing its dataProductDescriptor property to 1.1.0 , SHALL be a valid Data Product Descriptor 1.1.0 document, semantically equivalent to the original Data Product Descriptor 1.0.2 document. New minor versions of the Data Product Descriptor Specification MUST be written to ensure this form of backward compatibility. Format \u2693\ufe0e A Data Product Descriptor Document that conforms to the Data Product Descriptor Specification is itself a JSON object, which may be represented either in JSON or YAML format. For example, if a field has an array value, the JSON array representation will be used: { \"field\" : [ 1 , 2 , 3 ] } All field names in the specification are case sensitive . This includes all fields that are used as keys in a map, except where explicitly noted that keys are case insensitive . The schema exposes two types of fields: Fixed fields, which have a declared name, and Patterned fields, which declare a regex pattern for the field name. Patterned fields MUST have unique names within the containing object. In order to preserve the ability to round-trip between YAML and JSON formats, YAML version 1.2 is RECOMMENDED along with some additional constraints: Tags MUST be limited to those allowed by the JSON Schema ruleset . Keys used in YAML maps MUST be limited to a scalar string, as defined by the YAML Failsafe schema ruleset . Document Structure \u2693\ufe0e A Data Product Descriptor Document MAY be made up of a single document or be divided into multiple, connected parts at the discretion of the user. In the latter case a Reference Objects is used. It is RECOMMENDED that the root Data Product Descriptor Document be named: data-product-descriptor.json or data-product-descriptor.yaml . Object Types \u2693\ufe0e A Data Product Descriptor Document have one and only one root object. The properties of an object are described by its fields. A field type can be another object or a primitive type . An addressable and versioned object is called entity. The root object of the Data Product Descriptor Document is an entity object. Other entities that exist only in the scope of the root entity are called components. Data Types \u2693\ufe0e Primitive data types in the DPDS are based on the types supported by the JSON Schema Specification Wright Draft 00 . Primitives have an optional modifier property: format . DPDS uses several known formats to define in fine detail the data type being used. However, to support documentation needs, the format property is an open string -valued property, and can have any value. Formats such as \"email\" , \"uuid\" , and so on, MAY be used even though undefined by this specification. Types that are not accompanied by a format property follow the type definition in the JSON Schema. Tools that do not recognize a specific format MAY default back to the type alone, as if the format is not specified. The formats defined by the DPDS are: type format Comments integer int32 signed 32 bits integer int64 signed 64 bits (a.k.a long) number float number double string string alphanumeric a string that match the following regex ^[a-zA-Z0-9]+$ string name a string that match the following regex ^[a-zA-Z][a-zA-Z0-9]+$ string fqn a string that match the following regex ^[a-zA-Z][a-zA-Z0-9.:]+$ string version a string that match the following regex ^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$ string byte base64 encoded characters string binary any sequence of octets string uuid a sequence of 16 octets as defined by RFC4122 boolean string date As defined by full-date - RFC3339 string date-time As defined by date-time - RFC3339 string password A hint to UIs to obscure input. Rich Text Formatting \u2693\ufe0e Throughout the specification description fields are noted as supporting CommonMark markdown formatting. Where Data Product Descriptor tooling renders rich text it MUST support, at a minimum, markdown syntax as described by CommonMark 0.27 . Tooling MAY choose to ignore some CommonMark features to address security concerns. Relative References in URLs \u2693\ufe0e Unless specified otherwise, all properties that are URLs SHOULD be absolute references. If a property explicitly specify in its description that allows a relative reference its value MUST be compliant with RFC3986 . Relative references MUST be resolved using the URLs defined in the property description as a Base URI. Relative references used in $ref are processed as per JSON Reference , using the URL of the current document as the base URI. See also the Reference Object . Schema \u2693\ufe0e In the following description, if a field is not explicitly REQUIRED or described with a MUST or SHALL, it can be considered OPTIONAL. Data Product Descriptor Entity \u2693\ufe0e This is the root object of the Data Product Descriptor Document . Fixed Fields \u2693\ufe0e Field Name Type Description dataProductDescriptor string:version (REQUIRED) The semantic version number of the Data Product Descriptor Specification Version that the Data Product Descriptor Document uses. The dataProductDescriptor field SHOULD be used by tooling specifications and clients to interpret the Data Product Descriptor Document . This is not related to the data product's info.version field. info Info Object (REQUIRED) The general information about the data product. The information can be used by the platform or by consumers if needed. interfaceComponents Interface Components Object (REQUIRED) The list of all interface entities exposed by the data product. internalComponents Internal Components Object The list of all internal entities that compose the data product. components Components Object An element to hold a set of reusable objects that can be referentiated in other part of the document. tags [ string ] A list of tags associated to the data product. Tags can be used for logical grouping of data products. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Info Object \u2693\ufe0e The Info Object contains general information about the data product. The information can be used by the platform or by consumers if needed. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 ( RFC-4122 ) generated server side during data product creation as SHA-1 hash of the fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to referentiate the data product. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to referentiate the data product when calling an API different from the ones exposed by the data product experience plane the fullyQualifiedName MUST be always used. Example: \"id: \"2b172838-73b1-5d6c-be45-cc75aee180a0\" fullyQualifiedName string:fqn (REQUIRED) The unique universal idetifier of the data product. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version} . It's RECOMMENDED to use as mesh-namespace your company's domain name in reverse dot notation (es it.quantyca ) in order to ensure that the fullyQualifiedName is unique universal idetifier as REQUIRED. To the mesh-nemaspace MAY be added as postfix the product's 'domain' (es. planning , operations , ...). Using the data product's domain as postfix in the mesh-namespace is anyway NOT RECOMMENDED. Example: \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1\" . entityType string:alphanumeric (READONLY) The type of the entity. It MUST be a constant value equals to dataproduct . name string:name (REQUIRED) The name of the data product. MUST be unique within the mesh-namespace . It's RECOMMENDED to use a camel case formatted string. version string:version (REQUIRED) The semantic version number of the data product definition contained in the given Data Product Descriptor Document . Everytime the major version of one of the data product's ports changes also the major version of the product MUST be incremented. It is RECOMMENDED to use 0 as major version for data products that are not yet general available. These data products can introduce breaking changes without incrementing their major version . It is anyway RECOMMENDED that for every breaking change introduced by a data product that is not yet general available (i.e. major version equals to 0) at least the minor version is incremented. This field is not related to the dataProductDescriptor field. displayName string The human readable name of the data product. It SHOULD be used by frontend tool to visualize data product's name in place of the name property. It's RECOMMENDED to not use the same displayName for different data products belonging to the same mesh-namespace . description string The data product description. CommonMark syntax MAY be used for rich text representation. domain string:name (REQUIRED) The domain to which the data product belongs to. owner Owner Object A collection of information related to the data product's owner. contactPoints [ Contact Point Object ] A collection of contact information for the given data product. This object MAY be extended with Specification Extensions . Owner Object \u2693\ufe0e The Owner Object describes the data product's owner. Fixed Fields \u2693\ufe0e Field Name Type Description id string (REQUIRED) The identifier of the data product's owner. It's RECOMMENDED to use the corporate mail of the owner as identifier. name string The full name of the data product's owner This object MAY be extended with Specification Extensions . Owner Object Example: \u2693\ufe0e { \"id\" : \"john.doe@company-xyz.com\" , \"name\" : \"John Doe\" } Contact Point Object \u2693\ufe0e The Contact Point Object describes a data product's contact point. Fixed Fields \u2693\ufe0e Field Name Type Description name string:name The name of the contact point. description string The contact point description. CommonMark syntax MAY be used for rich text representation. channel string The channel used to address the contact point. It can be for example equal to web , mail or phone . address string The address of the contact point. Depending on the channel it can be for example an URL, an email address or a phone number. This object MAY be extended with Specification Extensions . Contact Point Object Example: \u2693\ufe0e { \"name\" : \"Support Team Mail\" , \"description\" : \"The mail address of to the team that give support on this product\" , \"channel\" : \"email\" , \"address\" : \"trip-execution-support@company-xyz.com\" } { \"name\" : \"Issue Tracker\" , \"description\" : \"The address of the issue tracker associated to this product\" , \"channel\" : \"web\" , \"address\" : \"https://readmine.company-xyz.com/trip-execution\" } Interface Components Object \u2693\ufe0e The Interface Components Object it's a collection of all interface entities exposed by a data product. Fixed Fields \u2693\ufe0e Field Name Type Description inputPorts [ Input Port Component | Reference Object ] The input ports exposed by the data product. outputPorts [ Output Port Component | Reference Object ] (REQUIRED) The output ports exposed by the data product. discoveryPorts [ Discovery Port Component | Reference Object ] The discovery ports exposed by the data product. observabilityPorts [ Observability Port Component | Reference Object ] The observability ports exposed by the data product. controlPorts [ Control Port Component | Reference Object ] The control ports exposed by the data product. This object cannot be extended with additional properties and any properties added SHALL be ignored. Input Port Component \u2693\ufe0e The Input Port Component describes an input port of a data product. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the port's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to referentiate the port. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to referentiate the data product when calling API different from the ones exposed by the data product experience plane the port's fullyQualifiedName MUST be always used. Example: \"id\": \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) . The unique universal idetifier of the port. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:inputports:{port-name} . Example: \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:inputports:tmsTripCDC\" . entityType string:alphanumeric The type of the entity. It MUST be a constant value equals to inputport . name string:name (REQUIRED) The name of the port. It MUST be unique within the other input ports of the same data product. It's RECOMMENDED to use a cammel case formatted string. Example \"name: \"tmsTripCDC\" . version string:version (REQUIRED) The semantic version number of the data product's port. Everytime the major version of port changes also the major version of the product MUST be incremented. displayName string The human readable name of the port. It SHOULD be used by frontend tool to visualize port's name in place of the name property. It's RECOMMENDED to not use the same displayName for different input ports belonging to the same data product. description string The port descripion. CommonMark syntax MAY be used for rich text representation. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. promises Promises Object | Reference Object The data product's promises declared over the port. expectations Expectation Object | Reference Object The data product's expectations declared over the port. contracts Contracts Object | Reference Object The data product's contracts declared over the port. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Output Port Component \u2693\ufe0e The Output Port Component describes an output port of a data product. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the port's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to referentiate the port. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to referentiate the data product when calling API different from the ones exposed by the data product experience plane the port's fullyQualifiedName MUST be always used. Example: \"id\": \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) The unique universal idetifier of the port. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:inputports:{port-name} . Example \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:inputports:tmsTripCDC\" . entityType string:alphanumeric The type of the entity. It MUST be a constant value equals to outputport . name string:name (REQUIRED) The name of the port. MUST be unique within the other input ports of the same data product. It's RECOMMENDED to use a cammel case formatted string. Example \"name: \"tmsTripCDC\" . version string:version (REQUIRED) The semantic version number of the data product's port. Everytime the major version of port changes also the major version of the product MUST be incremented. displayName string The human readable name of the port. It SHOULD be used by frontend tool to visualize port's name in place of the name property. It's RECOMMENDED to not use the same displayName for different input ports belonging to the same data product. description string The port descripion. CommonMark syntax MAY be used for rich text representation. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. promises Promises Object | Reference Object The data product's promises declared over the port. expectations Expectation Object | Reference Object The data product's expectations declared over the port. contracts Contracts Object | Reference Object The data product's contracts declared over the port. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Discovey Port Component \u2693\ufe0e The Discovey Port Component describes a discovery port of a data product. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the port's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to referentiate the port. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to referentiate the data product when calling API different from the ones exposed by the data product experience plane the port's fullyQualified name MUST be always used. \"id: \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) . The unique universal idetifier of the port. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:inputports:{port-name} . Example \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:inputports:tmsTripCDC\" . entityType string:alphanumeric The type of the entity. It MUST be a constant value equals to discoveryport . name string:name (REQUIRED) The name of the port. MUST be unique within the other input ports of the same data product. It's RECOMMENDED to use a cammel case formatted string. Example \"name: \"tmsTripCDC\" . version string:version (REQUIRED) The semantic version number of the data product's port. Everytime the major version of port changes also the major version of the product MUST be incremented. displayName string The human readable name of the port. It SHOULD be used by frontend tool to visualize port's name in place of the name property. It's RECOMMENDED to not use the same displayName for different input ports belonging to the same data product. description string The port descripion. CommonMark syntax MAY be used for rich text representation. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. promises Promises Object | Reference Object The data product's promises declared over the port. expectations Expectation Object | Reference Object The data product's expectations declared over the port. contracts Contracts Object | Reference Object The data product's contracts declared over the port. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Observability Port Component \u2693\ufe0e The Observability Port Component describes an observability port of a data product. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the port's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to referentiate the port. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to referentiate the data product when calling API different from the ones exposed by the data product experience plane the port's fullyQualified name MUST be always used. \"id: \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) The unique universal idetifier of the port. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:inputports:{port-name} . Example \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:inputports:tmsTripCDC\" . entityType string:alphanumeric The type of the entity. It MUST be a constant value equals to observabilityport . name string:name (REQUIRED) The name of the port. MUST be unique within the other input ports of the same data product. It's RECOMMENDED to use a cammel case formatted string. Example \"name: \"tmsTripCDC\" . version string:version (REQUIRED) The semantic version number of the data product's port. Everytime the major version of port changes also the major version of the product MUST be incremented. displayName string The human readable name of the port. It SHOULD be used by frontend tool to visualize port's name in place of the name property. It's RECOMMENDED to not use the same displayName for different input ports belonging to the same data product. description string The port descripion. CommonMark syntax MAY be used for rich text representation. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. promises Promises Object | Reference Object The data product's promises declared over the port. expectations Expectation Object | Reference Object The data product's expectations declared over the port. contracts Contracts Object | Reference Object The data product's contracts declared over the port. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Control Port Component \u2693\ufe0e The Control Port Component describes a control port of a data product. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the port's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to referentiate the port. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to referentiate the data product when calling API different from the ones exposed by the data product experience plane the port's fullyQualified name MUST be always used. \"id: \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) . The unique universal idetifier of the port. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:inputports:{port-name} . Example \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:inputports:tmsTripCDC\" . entityType string:alphanumeric The type of the entity. It MUST be a constant value equals to controlport . name string:name (REQUIRED) The name of the port. MUST be unique within the other input ports of the same data product. It's RECOMMENDED to use a cammel case formatted string. Example \"name: \"tmsTripCDC\" . version string:version (REQUIRED) The semantic version number of the data product's port. Everytime the major version of port changes also the major version of the product MUST be incremented. displayName string The human readable name of the port. It SHOULD be used by frontend tool to visualize port's name in place of the name property. It's RECOMMENDED to not use the same displayName for different input ports belonging to the same data product. description string The port descripion. CommonMark syntax MAY be used for rich text representation. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. promises Promises Object | Reference Object The data product's promises declared over the port. expectations Expectation Object | Reference Object The data product's expectations declared over the port. contracts Contracts Object | Reference Object The data product's contracts declared over the port. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Promises Object \u2693\ufe0e The Promises Object describes the data product's promises declared over a given port. Fixed Fields \u2693\ufe0e Field Name Type Description platform string The target technological platform in which the services associated with the given port operate. It contains usually the infrastructure provider and data center location. Optionally it can contains also the specific runtime technology used. Examples: onprem:milan-1 , aws:eu-south-1 , aws:eu-south-1:redshift . servicesType string The type of services associated with the given port. Examples: soap-services , rest-services , odata-services , streaming-services , datastore-services . api Standard Definition Object The formal description of port's services API. It is RECOMMENDED to use Open API Specification for restfull services, Async API Specification for streaming services and DataStore API Specification for data store connection based services. Other specifications MAY be used as required. depreceationPolicy Specification Extension Point The deprecation policy adopted by the port. It is RECOMMENDED to specify at least how long the deprecation period will be after the release of a new major version. slo Specification Extension Point The service level objectives supported by the port. It is RECOMMENDED to group SLO by category (ex. operational SLO, quality SLO, etc ...) and specify them in an easy to compute way. This object MAY be extended with Specification Extensions . Expectations Object \u2693\ufe0e The Expectations Object describes the data product's expectations declared over a given port. Fixed Fields \u2693\ufe0e Field Name Type Description audience Specification Extension Point The audience of consumers for whom the the port has been designed. It is RECOMMENDED to specify inclusion and exclusion criteria in a way that is not ambiguous. usage Specification Extension Point The usage patterns for which the port has been designed. This object MAY be extended with Specification Extensions . Contracts Object \u2693\ufe0e The Contracts Object describes the data product's contracts declared over a given port. Fixed Fields \u2693\ufe0e Field Name Type Description termsAndConditions Specification Extension Point The terms and conditions defined on the port on which consumers must agree on and respect in order to use it. billingPolicy Specification Extension Point The billing policy defined on the port on which consumers must agree on and respect in order to use it. sla Specification Extension Point The service level agreements supported by the port. It is RECOMMENDED to group SLA by category (ex. operational SLA, quality SLA, ecc ...) and specify them in an easy to compute way. This object MAY be extended with Specification Extensions . Internal Components Object \u2693\ufe0e The Internal Components Object it's a collection of all internal entities that compose a data product. Fixed Fields \u2693\ufe0e Field Name Type Description applicationComponents [ Application Component ] The list of application component that compose the data product. infrastructuralComponents [ Infrastructural Component ] The list of infrastructural components that compose the data product. This object cannot be extended with additional properties and any properties added SHALL be ignored. Application Component \u2693\ufe0e The Application Component describes an internal application component used by the data product to provide services through its ports. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the component's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to address the component. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to address the component when calling API different from the ones exposed by the data product experience plane the component's fullyQualifiedName MUST be always used. Examples: \"id: \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) . The unique universal idetifier of the component. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:applications:{app-name} . Example \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:applications:modelNormalizationJob\" . entityType string:alphanumeric (READONLY) The type of the entity. It is a constant value equals to application . name string:name The name of the application component. MUST be unique within the other application components of the same data product. It's RECOMMENDED to use a camel case formatted string. Example \"name: \"modelNormalizationJob\" . version string:version (REQUIRED) The semantic version number of the data product's application component. displayName string The human readable name of the component. It SHOULD be used by frontend tool to visualize application component's name in place of the name property. It's RECOMMENDED to not use the same displayName for different application component belonging to the same data product. description string The application component description. CommonMark syntax MAY be used for rich text representation. platform string The target technological platform on which the application will be deployed. It contains usually the infrastructure provider and data center location. Optionally it can contains also the specific runtime technology used. Examples: onprem:milan-1 , aws:eu-south-1 , aws:eu-south-1:redshift . applicationType string The type of the application: Examples: stream-sourcing , batch-sourcing , streaming-transformation , batch-transformation , housekeeping , ecc... buildInfo Build Info Object The information required to build the application component. deployInfo Deploy Info Object The information required to deploy the application component. consumesFrom [ string:fqn ] The list of ports or infrastructural components from which the application consumes directly data or services. providesTo [ string:fqn ] The list of ports or infrastructural components to which the application provides directly data or services. dependsOn [ string:fqn ] A list of other internal components on which this application directly depends on. It is used during data product deployment to define a consistent deployment plan. Cyclic dependencies between components MUST be avoided. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Build Info Object \u2693\ufe0e The Build Info Object contains all the informations required to build an Application Component Fixed Fields \u2693\ufe0e Field Name Type Description service string:name | External Resource Object The logical name or the actual endpoint of the service to call in order to build the application component. If the logical name is used as field value the actual endpoint value resulution is demanded to the data product experience plane of the underlyng platform. buildTemplate object | Reference Object | External Resource Object Can be an inline JSON or a refernce to an external resource. It contains the definition of the pipeline to execute in order to build the application. It is passed as is to the build service specified using the buildService field. buildConfigurations object | Reference Object | External Resource Object Can be an inline JSON or a refernce to an external resource. It contains the configuration properties that can be used by the build service at build time. It is passed as is to the build service specified using the buildService field. This object MAY be extended with Specification Extensions . Deploy Info Object \u2693\ufe0e The Deploy Info Object contains all the informations required to deploy an Application Component Fixed Fields \u2693\ufe0e Field Name Type Description service string:name | External Resource Object The logical name or the actual endpoint of the service to call in order to deploy the application component. If the logical name is used as field value the actual endpoint value resulution is demanded to the data product experience plane of the underlyng platform. template object | Reference Object | External Resource Object Can be an inline JSON or a refernce to an external resource. It contains the definition of the pipeline to execute in order to deploy the application. It is passed as is to the deployment service specified using the deploymentService field. configurations object | Reference Object | External Resource Object Can be an inline JSON or a refernce to an external resource. It contains the configuration properties that can be used by the deployment service at deploy time. It is passed as is to the deployment service specified using the deploymentService field. This object MAY be extended with Specification Extensions . Infrastructural Component \u2693\ufe0e The Infrastructural Component describes an internal infrastructural component used by the data product to run its applications and store its data. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the component's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to address the component. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to address the component when calling API different from the ones exposed by the data product experience plane the component's fullyQualifiedName MUST be always used. Examples: \"id: \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) . The unique universal idetifier of the component. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:infrastructure:{infra-name} . Example \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:infrastructure:stagingArea\" . entityType string:alphanumeric (READONLY) The type of the entity. It is a constant value equals to infrastructure . name string:name The name of the infrastructural component. MUST be unique within the other infrastructural components of the same data product. It's RECOMMENDED to use a camel case formatted string. Example \"name: \"stagingArea\" . version string:version (REQUIRED) The semantic version number of the data product's infrastructural component. displayName string The human readable name of the component. It SHOULD be used by frontend tool to visualize application component's name in place of the name property. It's RECOMMENDED to not use the same displayName for different infrastructural component belonging to the same data product. description string The infrastructural component descripion. CommonMark syntax MAY be used for rich text representation. platform string The target technological platform on which the infrastructural component will be provisioned. It contains usually the infrastructure provider and data center location. Optionally it can contains also the specific resource object that will be provisioned. Examples: onprem:milan-1 , aws:eu-south-1 , aws:eu-south-1:s3-buket . infrastructureType string The type of the infrastructural component. Examples: computation-resource , storage-resource , networking-resource , ecc... provisionInfo Provision Info Object The information required to provision the infrastructural component. dependsOn [ string:fqn ] A list of other infrastructural components on which this component directly depends on. It is used during infrastructure provisioning to define a consistent provisioning plan. Cyclic dependencies between infrastructural components MUST be avoided. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Provision Info Object \u2693\ufe0e The Provision Info Object contains all the informations required to provision an Infrastructural Component Fixed Fields \u2693\ufe0e Field Name Type Description service string:name | External Resource Object The logical name or the actual endpoint of the service to call in order to provision the infrastructural component. If the logical name is used as field value the actual endpoint value resulution is demanded to the data product experience plane of the underlyng platform. template object | Reference Object | External Resource Object Can be an inline JSON or a refernce to an external resource. It contains the definition of the resources to provision. It is passed as is to the provisioning service specified using the provisionService field. configurations object | Reference Object | External Resource Object Can be an inline JSON or a refernce to an external resource. It contains the configuration properties that can be used by the provisioning service at provision time. It is passed as is to the provision service specified using the provisioningService field. This object MAY be extended with Specification Extensions . Components Object \u2693\ufe0e The Components Object holds a set of reusable objects for different aspects of the DPDS. All objects defined within the components object will have no effect on the Data Product Descriptor unless they are explicitly referenced from properties outside the components object. Fixed Fields \u2693\ufe0e Field Name Type Description inputPorts Map[ string , Input Port Component | Reference Object ] An object to hold reusable Input Port Component . outputPorts Map[ string , Output Port Component | Reference Object ] An object to hold reusable Output Port Component . discoveryPorts Map[ string , Discovery Port Component | Reference Object ] An object to hold reusable Discovery Port Component . observabilityPorts Map[ string , Observability Port Component | Reference Object ] An object to hold reusable Observability Port Component . controlPorts Map[ string , Control Port Component | Reference Object ] An object to hold reusable Control Port Component . applicationComponents Map[ string , Application Component | Reference Object ] An object to hold reusable Application Component . infrastructuralComponents Map[ string , Infrastructural Component | Reference Object ] An object to hold reusable Infrastructural Component . This object MAY be extended with Specification Extensions . All the fixed fields declared above are objects that MUST use keys that match the regular expression: ^[a-zA-Z0-9\\.\\-_]+$ . Reference Object \u2693\ufe0e The Reference Object allows referencing other components in the Data Product Descriptor Document , internally and externally. The $ref string value contains a URI RFC3986 , which identifies the location of the value being referenced. See the rules for resolving Relative References . Fixed Fields \u2693\ufe0e Field Name Type Description description string A description which by default SHOULD override that of the referenced component. CommonMark syntax MAY be used for rich text representation. If the referenced object-type does not allow a description field, then this field has no effect. $ref string REQUIRED . The reference identifier. This MUST be in the form of a URI. This object cannot be extended with additional properties and any properties added SHALL be ignored. Reference Object Example \u2693\ufe0e { \"$ref\" : \"#/components/schemas/Pet\" } Relative Schema Document Example \u2693\ufe0e { \"$ref\" : \"Pet.json\" } Relative Documents With Embedded Schema Example \u2693\ufe0e { \"$ref\" : \"definitions.json#/Pet\" } External Resource Object \u2693\ufe0e The External Resource Object allows referencing an external resource like a documentation page or a standard definition. Fixed Fields \u2693\ufe0e Field Name Type Description description string A description of the target resource. CommonMark syntax MAY be used for rich text representation. mediaType string The media type of target resource. It must conform to media type format, according to RFC6838 . $href string:uri REQUIRED . The URI of the target resource. It must conform to the URI format, according to RFC3986 . This object cannot be extended with additional properties and any properties added SHALL be ignored. External Resource Object Example \u2693\ufe0e { \"description\" : \"Find more info here\" , \"mediaType\" : \"text/html\" , \"$href\" : \"https://example.com\" } Standard Definition Object \u2693\ufe0e The Standard Definition Object formally describes an object (ex. API object, provision template object, ecc ...) of interest following a given standard specification. Fixed Fields \u2693\ufe0e Field Name Type Description description string The standard definition descripion. CommonMark syntax MAY be used for rich text representation. specification string (REQUIRED) The external specification used in the definition . version string The version of the external specification used in the definition . If not defined the version MUST be included in the definition itself. definition object | Reference Object | External Resource Object (REQUIRED) The formal definition built using the spcification declared in the [specification](#standardDefinitionSpecification) field. externalDocs External Resource Object Additional external documentation for the standard definition. This object MAY be extended with Specification Extensions . Standard Definition Object Example: \u2693\ufe0e { \"description\" : \"The API exposed by the Observability Port that exposes data product logs\" , \"specification\" : \"openapi\" , \"version\" : \"3.1.0\" , \"definition\" : { \"mediaType\" : \"text/json\" , \"$href\" : \"https://mycompany.com/api/v1/planes/utility/logging-services/openapi.json\" }, \"externalDocs\" : { \"mediaType\" : \"text/html\" , \"$href\" : \"https://spec.openapis.org/oas/v3.1.0\" } } Specification Extension Point \u2693\ufe0e A Specification Extension Point marks specific part of the Data Product Descriptor Specification that are left open to extensions or futher evolution of the standard. While a Standard Definition it's a formal declaration that the description of a part of the Data Product Descriptor Specification will be demanded to an external standards in this verion of the specification and in the future ones, the same assumption it's not true for Specification Extension Point . Even if a Specification Extension Point can be extended at will it is RECOMMENDED to use for all added properties a field name prefixed by \"x-\" in order to avoid potetntial conflicts with future versions of the Data Product Descriptor Specification . Fixed Fields \u2693\ufe0e Field Name Type Description description string The extention point descripion. CommonMark syntax MAY be used for rich text representation. externalDocs External Resource Object Additional external documentation for the extention point This object MAY be extended with Specification Extensions . Specification Extensions \u2693\ufe0e While the Data Product Descriptor Specification tries to accommodate most use cases, additional data can be added to extend the specification at certain points. The extensions properties are implemented as patterned fields that are always prefixed by \"x-\" . Field Pattern Type Description ^x- Any Allows extensions to the Data Product Descriptor Schema. The field name MUST begin with x- , for example, x-internal-id . The value can be null , a primitive, an array or an object. Can have any valid JSON format value. The extensions may or may not be supported by the available tooling, but those may be extended as well to add requested support (if tools are internal or open-sourced). Appendix A: Revision History \u2693\ufe0e Version Date Notes 1.0.0 2022-11-01 Release of the Data Product Descriptor Specification 1.0.0","title":"1.0.0."},{"location":"references/specifications/1.0.0/#data-product-descriptor-specification","text":"","title":"Data Product Descriptor Specification"},{"location":"references/specifications/1.0.0/#version-100","text":"The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 RFC2119 RFC8174 when, and only when, they appear in all capitals, as shown here. This document is licensed under The Apache License, Version 2.0 .","title":"Version 1.0.0"},{"location":"references/specifications/1.0.0/#disclaimer","text":"Part of this content has been taken from the great work done by the folks at the OpenAPI Initiative and AsyncAPI Initiative . We have decided to not reinvent the wheel and inspire our work to these two specifications mainly for the following reasons: We think that the work made by OpenAPI Initiative and AsyncAPI Initiative is great :) We want to make the learning curve for the Data Product Descriptor Specification as smooth as possible, aligning its definition to the one of other two popular specifications in the software and data engineers community We think that OpenAPI and AsyncAPI are natural specifications for defining the interface of data product's ports that expose an API endpoint. This specification do not impose to use any specific standard for port's interface definition but these two are highly recommended.","title":"Disclaimer"},{"location":"references/specifications/1.0.0/#introduction","text":"The Data Product Descriptor Specification (DPDS) defines a declarative and technology independent standard to describe a data product in all its components. It allows human agents (e.g. analysts, data scientists, etc..) and digital agents (e.g. other data products, BI tools, planes of the underlying data mesh ops platform, etc..) to operate, discover and access a data product. When properly defined, an external agent can understand and interact with the data product with a minimal amount of cognitive load and implementation logic. The formalization of a standard data product descriptor document through an open specification is useful to enable the implementation of an ecosystem of interoperable data mesh tools. The following is a non exhaustive list of tools that can benefit from the specification: catalogs (search, document and collaborate) design tools (create new products by composition of reusable templates) lifecycle management tools (deploy and operate) access management tools (assign/track access grants and generate client code in different languages) policies checking tools (enforce standard compliance and audit security) observability tools (monitor and detect) data lineage tools (trace data flows and perform forward/backward analysis) mesh topology analysis tools (calculate value/trust scores and detect structural problems) semantic tools (apply ontologies over mesh topology) domain specific language tools (create a collection af interconnected data products that implement together a specific value stream)","title":"Introduction"},{"location":"references/specifications/1.0.0/#table-of-contents","text":"Definitions Standard Standard Specification Standard Definition Data Product Data Product Ports Data Product Application Components Data Product Infrastructural Components Data Product Descriptor Document Data Product Descriptor Specification Specification Versions Format Document Structure Data Types Rich Text Formatting Relative References In URLs Schema Data Product Descriptor Entity Info Object Owner Object Contact Point Object Interface Components Object Input Port Component Output Port Component Discovery Port Component Observability Port Component Control Port Component Promises Object Expectations Object Contracts Object Internal Components Object Application Component Build Info Object Deploy Info Object Infrastructural Component Provision Info Object Components Object Reference Object External Resource Object Standard Definition Object Specification Extension Point Specification Extensions Appendix A: Revision History","title":"Table of Contents"},{"location":"references/specifications/1.0.0/#definitions","text":"","title":"Definitions"},{"location":"references/specifications/1.0.0/#specification","text":"","title":"Specification"},{"location":"references/specifications/1.0.0/#versions","text":"The Data Product Descriptor Specification is versioned using Semantic Versioning 2.0.0 (semver) and follows the semver specification. The major . minor portion of the semver (for example 1.0 ) SHALL designate the DPDS feature set. Typically, .patch versions address errors in this document, not the feature set. Tooling which supports DPDS 1.0 SHOULD be compatible with all DPDS 1.0.* versions. The patch version SHOULD NOT be considered by tooling, making no distinction between 1.0.0 and 1.0.1 for example. Each new minor version of the Data Product Descriptor Specification SHALL allow any Product Descriptor document that is valid against any previous minor version of the Specification, within the same major version, to be updated to the new Specification version with equivalent semantics. Such an update MUST only require changing the dataProductDescriptor property to the new minor version. For example, a valid Data Product Descriptor 1.0.2 document, upon changing its dataProductDescriptor property to 1.1.0 , SHALL be a valid Data Product Descriptor 1.1.0 document, semantically equivalent to the original Data Product Descriptor 1.0.2 document. New minor versions of the Data Product Descriptor Specification MUST be written to ensure this form of backward compatibility.","title":" Versions"},{"location":"references/specifications/1.0.0/#format","text":"A Data Product Descriptor Document that conforms to the Data Product Descriptor Specification is itself a JSON object, which may be represented either in JSON or YAML format. For example, if a field has an array value, the JSON array representation will be used: { \"field\" : [ 1 , 2 , 3 ] } All field names in the specification are case sensitive . This includes all fields that are used as keys in a map, except where explicitly noted that keys are case insensitive . The schema exposes two types of fields: Fixed fields, which have a declared name, and Patterned fields, which declare a regex pattern for the field name. Patterned fields MUST have unique names within the containing object. In order to preserve the ability to round-trip between YAML and JSON formats, YAML version 1.2 is RECOMMENDED along with some additional constraints: Tags MUST be limited to those allowed by the JSON Schema ruleset . Keys used in YAML maps MUST be limited to a scalar string, as defined by the YAML Failsafe schema ruleset .","title":" Format"},{"location":"references/specifications/1.0.0/#document-structure","text":"A Data Product Descriptor Document MAY be made up of a single document or be divided into multiple, connected parts at the discretion of the user. In the latter case a Reference Objects is used. It is RECOMMENDED that the root Data Product Descriptor Document be named: data-product-descriptor.json or data-product-descriptor.yaml .","title":"Document Structure"},{"location":"references/specifications/1.0.0/#object-types","text":"A Data Product Descriptor Document have one and only one root object. The properties of an object are described by its fields. A field type can be another object or a primitive type . An addressable and versioned object is called entity. The root object of the Data Product Descriptor Document is an entity object. Other entities that exist only in the scope of the root entity are called components.","title":"Object Types"},{"location":"references/specifications/1.0.0/#data-types","text":"Primitive data types in the DPDS are based on the types supported by the JSON Schema Specification Wright Draft 00 . Primitives have an optional modifier property: format . DPDS uses several known formats to define in fine detail the data type being used. However, to support documentation needs, the format property is an open string -valued property, and can have any value. Formats such as \"email\" , \"uuid\" , and so on, MAY be used even though undefined by this specification. Types that are not accompanied by a format property follow the type definition in the JSON Schema. Tools that do not recognize a specific format MAY default back to the type alone, as if the format is not specified. The formats defined by the DPDS are: type format Comments integer int32 signed 32 bits integer int64 signed 64 bits (a.k.a long) number float number double string string alphanumeric a string that match the following regex ^[a-zA-Z0-9]+$ string name a string that match the following regex ^[a-zA-Z][a-zA-Z0-9]+$ string fqn a string that match the following regex ^[a-zA-Z][a-zA-Z0-9.:]+$ string version a string that match the following regex ^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$ string byte base64 encoded characters string binary any sequence of octets string uuid a sequence of 16 octets as defined by RFC4122 boolean string date As defined by full-date - RFC3339 string date-time As defined by date-time - RFC3339 string password A hint to UIs to obscure input.","title":"Data Types"},{"location":"references/specifications/1.0.0/#rich-text-formatting","text":"Throughout the specification description fields are noted as supporting CommonMark markdown formatting. Where Data Product Descriptor tooling renders rich text it MUST support, at a minimum, markdown syntax as described by CommonMark 0.27 . Tooling MAY choose to ignore some CommonMark features to address security concerns.","title":"Rich Text Formatting"},{"location":"references/specifications/1.0.0/#relative-references-in-urls","text":"Unless specified otherwise, all properties that are URLs SHOULD be absolute references. If a property explicitly specify in its description that allows a relative reference its value MUST be compliant with RFC3986 . Relative references MUST be resolved using the URLs defined in the property description as a Base URI. Relative references used in $ref are processed as per JSON Reference , using the URL of the current document as the base URI. See also the Reference Object .","title":"Relative References in URLs"},{"location":"references/specifications/1.0.0/#schema","text":"In the following description, if a field is not explicitly REQUIRED or described with a MUST or SHALL, it can be considered OPTIONAL.","title":"Schema"},{"location":"references/specifications/1.0.0/#data-product-descriptor-entity","text":"This is the root object of the Data Product Descriptor Document .","title":"Data Product Descriptor Entity"},{"location":"references/specifications/1.0.0/#info-object","text":"The Info Object contains general information about the data product. The information can be used by the platform or by consumers if needed.","title":"Info Object"},{"location":"references/specifications/1.0.0/#owner-object","text":"The Owner Object describes the data product's owner.","title":"Owner Object"},{"location":"references/specifications/1.0.0/#contact-point-object","text":"The Contact Point Object describes a data product's contact point.","title":"Contact Point Object"},{"location":"references/specifications/1.0.0/#interface-components-object","text":"The Interface Components Object it's a collection of all interface entities exposed by a data product.","title":"Interface Components Object"},{"location":"references/specifications/1.0.0/#input-port-component","text":"The Input Port Component describes an input port of a data product.","title":"Input Port Component"},{"location":"references/specifications/1.0.0/#output-port-component","text":"The Output Port Component describes an output port of a data product.","title":"Output Port Component"},{"location":"references/specifications/1.0.0/#discovey-port-component","text":"The Discovey Port Component describes a discovery port of a data product.","title":"Discovey Port Component"},{"location":"references/specifications/1.0.0/#observability-port-component","text":"The Observability Port Component describes an observability port of a data product.","title":"Observability Port Component"},{"location":"references/specifications/1.0.0/#control-port-component","text":"The Control Port Component describes a control port of a data product.","title":"Control Port Component"},{"location":"references/specifications/1.0.0/#promises-object","text":"The Promises Object describes the data product's promises declared over a given port.","title":"Promises Object"},{"location":"references/specifications/1.0.0/#expectations-object","text":"The Expectations Object describes the data product's expectations declared over a given port.","title":"Expectations Object"},{"location":"references/specifications/1.0.0/#contracts-object","text":"The Contracts Object describes the data product's contracts declared over a given port.","title":"Contracts Object"},{"location":"references/specifications/1.0.0/#internal-components-object","text":"The Internal Components Object it's a collection of all internal entities that compose a data product.","title":"Internal Components Object"},{"location":"references/specifications/1.0.0/#application-component","text":"The Application Component describes an internal application component used by the data product to provide services through its ports.","title":"Application Component"},{"location":"references/specifications/1.0.0/#build-info-object","text":"The Build Info Object contains all the informations required to build an Application Component","title":"Build Info Object"},{"location":"references/specifications/1.0.0/#deploy-info-object","text":"The Deploy Info Object contains all the informations required to deploy an Application Component","title":"Deploy Info Object"},{"location":"references/specifications/1.0.0/#infrastructural-component","text":"The Infrastructural Component describes an internal infrastructural component used by the data product to run its applications and store its data.","title":"Infrastructural Component"},{"location":"references/specifications/1.0.0/#provision-info-object","text":"The Provision Info Object contains all the informations required to provision an Infrastructural Component","title":"Provision Info Object"},{"location":"references/specifications/1.0.0/#components-object","text":"The Components Object holds a set of reusable objects for different aspects of the DPDS. All objects defined within the components object will have no effect on the Data Product Descriptor unless they are explicitly referenced from properties outside the components object.","title":"Components Object"},{"location":"references/specifications/1.0.0/#reference-object","text":"The Reference Object allows referencing other components in the Data Product Descriptor Document , internally and externally. The $ref string value contains a URI RFC3986 , which identifies the location of the value being referenced. See the rules for resolving Relative References .","title":"Reference Object"},{"location":"references/specifications/1.0.0/#external-resource-object","text":"The External Resource Object allows referencing an external resource like a documentation page or a standard definition.","title":"External Resource Object"},{"location":"references/specifications/1.0.0/#standard-definition-object","text":"The Standard Definition Object formally describes an object (ex. API object, provision template object, ecc ...) of interest following a given standard specification.","title":"Standard Definition Object"},{"location":"references/specifications/1.0.0/#specification-extension-point","text":"A Specification Extension Point marks specific part of the Data Product Descriptor Specification that are left open to extensions or futher evolution of the standard. While a Standard Definition it's a formal declaration that the description of a part of the Data Product Descriptor Specification will be demanded to an external standards in this verion of the specification and in the future ones, the same assumption it's not true for Specification Extension Point . Even if a Specification Extension Point can be extended at will it is RECOMMENDED to use for all added properties a field name prefixed by \"x-\" in order to avoid potetntial conflicts with future versions of the Data Product Descriptor Specification .","title":"Specification Extension Point"},{"location":"references/specifications/1.0.0/#specification-extensions","text":"While the Data Product Descriptor Specification tries to accommodate most use cases, additional data can be added to extend the specification at certain points. The extensions properties are implemented as patterned fields that are always prefixed by \"x-\" . Field Pattern Type Description ^x- Any Allows extensions to the Data Product Descriptor Schema. The field name MUST begin with x- , for example, x-internal-id . The value can be null , a primitive, an array or an object. Can have any valid JSON format value. The extensions may or may not be supported by the available tooling, but those may be extended as well to add requested support (if tools are internal or open-sourced).","title":"Specification Extensions"},{"location":"references/specifications/1.0.0/#appendix-a-revision-history","text":"Version Date Notes 1.0.0 2022-11-01 Release of the Data Product Descriptor Specification 1.0.0","title":"Appendix A: Revision History"},{"location":"references/specifications/last/","text":"Data Product Descriptor Specification \u2693\ufe0e Version 1.0.0 \u2693\ufe0e The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 RFC2119 RFC8174 when, and only when, they appear in all capitals, as shown here. This document is licensed under The Apache License, Version 2.0 . Disclaimer \u2693\ufe0e Part of this content has been taken from the great work done by the folks at the OpenAPI Initiative and AsyncAPI Initiative . We have decided to not reinvent the wheel and inspire our work to these two specifications mainly for the following reasons: We think that the work made by OpenAPI Initiative and AsyncAPI Initiative is great :) We want to make the learning curve for the Data Product Descriptor Specification as smooth as possible, aligning its definition to the one of other two popular specifications in the software and data engineers community We think that OpenAPI and AsyncAPI are natural specifications for defining the interface of data product's ports that expose an API endpoint. This specification do not impose to use any specific standard for port's interface definition but these two are highly recommended. Introduction \u2693\ufe0e The Data Product Descriptor Specification (DPDS) defines a declarative and technology independent standard to describe a data product in all its components. It allows human agents (e.g. analysts, data scientists, etc..) and digital agents (e.g. other data products, BI tools, planes of the underlying data mesh ops platform, etc..) to operate, discover and access a data product. When properly defined, an external agent can understand and interact with the data product with a minimal amount of cognitive load and implementation logic. The formalization of a standard data product descriptor document through an open specification is useful to enable the implementation of an ecosystem of interoperable data mesh tools. The following is a non exhaustive list of tools that can benefit from the specification: catalogs (search, document and collaborate) design tools (create new products by composition of reusable templates) lifecycle management tools (deploy and operate) access management tools (assign/track access grants and generate client code in different languages) policies checking tools (enforce standard compliance and audit security) observability tools (monitor and detect) data lineage tools (trace data flows and perform forward/backward analysis) mesh topology analysis tools (calculate value/trust scores and detect structural problems) semantic tools (apply ontologies over mesh topology) domain specific language tools (create a collection af interconnected data products that implement together a specific value stream) Table of Contents \u2693\ufe0e Definitions Standard Standard Specification Standard Definition Data Product Data Product Ports Data Product Application Components Data Product Infrastructural Components Data Product Descriptor Document Data Product Descriptor Specification Specification Versions Format Document Structure Data Types Rich Text Formatting Relative References In URLs Schema Data Product Descriptor Entity Info Object Owner Object Contact Point Object Interface Components Object Input Port Component Output Port Component Discovery Port Component Observability Port Component Control Port Component Promises Object Expectations Object Contracts Object Internal Components Object Application Component Build Info Object Deploy Info Object Infrastructural Component Provision Info Object Components Object Reference Object External Resource Object Standard Definition Object Specification Extension Point Specification Extensions Appendix A: Revision History Definitions \u2693\ufe0e Standard \u2693\ufe0e The set of shared rules used by different agents to describe an entity or process of common interest. The agents that follow the standard limit their autonomy conforming to the set of shared rules in order to facilitate cooperation between them through interoperability. Standard Specification \u2693\ufe0e The formal description of the rules that form a standard . A standard can have multiple specification versions associated to it. Sometime the words standard and specification are used as synonymous. Standard Definition \u2693\ufe0e The description of one specific entity or process created using and conforming to the set of rules formally described in the standard specification Data Product \u2693\ufe0e The smallest unit that can be independently deployed and managed in a data architecture (i.e. architectural quantum). It is composed by all the structural components that it requires to do its function: metadata, data, code, policies that govern the data and its dependencies to infrastructure. Each data product has a clear identifier, a version number and an owner. Data Product Ports \u2693\ufe0e The interfaces exposed to external agents by a data product . Each port expose a service or set of correlated services. These are the five types of port supported by a data product : Input port(s): an input port describes a set of services exposed by a data product to collect its source data and makes it available for further internal transformation. An input port can receive data from one ore more upstream sources in a push (i.e. asynchronous subscription) or pop mode (i.e. synchronous query). Each data product may have one or more input ports. Output port(s): an output port describes a set of services exposed by a data product to share the generated data in a way that can be understood and trusted. Each data product may have one or more output ports. Discovery port(s): a discovery port describes a set of services exposed by a data product to provide information about its static role in the overall architecture like purpose, structure, location, etc.. Each data product may have one or multiple discovery ports. Observability port(s): an observability port describes a set of services exposed by a data product to provide information about its dynamic behaviour in the overall architecture like logs, traces, audit trails, metrics, etc.. Each data product may have one or more observability ports. Control port(s): a control port describes a set of services exposed by a data product to configure local policies or perform highly privileged governance operations. Each data product may have one or more control ports. The data product descriptor specification uses the following concepts of promises theory to formally describe the set of services exposed by each port regardless of the specific type: Promises: Through promises the data product declares the intent of the port. Promises are not a guarantee of the outcome but the data product will behave accordingly to them in order to realize its intent. The more a data product keeps its promises over time and the more trustworthy it is. Thus, the more trustworthy a data product is the more potential consumers are likely to use it. Trust is based on the verification of how good a data product was in the past in keeping its promises. This verification should be automated by the underlying platform and synthetized in a trust score shared with all potential consumers. Example of promises are: description of services' API, SLO, deprecation policy, etc.. Expectations: Through expectations the data product declares how it wants the port to be used by its consumers. Expectations are the inverse of promises. They are a way to explicitly state what promises the data product would like consumers to make regarding how they will use the port. Example of expectations are: intended usage, intended audience, etc.. Contracts: Through contracts the data product declares promises and expectations that must be respected by the data product and its consumers. A contract is an explicit agreement between the data product and its consumers. It is used to group all the promises and expectations that if not respected can generate penalties like monetary sanctions or interruption of service. Example of contracts are: terms of conditions, SLA, billing policy, etc.. The governance can use these concepts to standardize the definition of these interfaces across all data products, while the platform can use them to provide the mechanisms to implement the described services in a compliant way. Data Product Application Components \u2693\ufe0e The components of a data product that implement the services exposed through its ports (i.e. pipelines, microservices, etc..). Data Product Infrastructural Components \u2693\ufe0e The components of a data product related to the infrastructural resources (i.e. storage, compute, etc..) used to run its application components . Data Product Descriptor Document \u2693\ufe0e The document (or set of documents) that contains the standard definition of a data product created using and conforming to the Data Product Descriptor Specification . Data Product Descriptor Specification \u2693\ufe0e The formal description of the rules to follow in order to create a standard compliant Data Product Descriptor Document . Specification \u2693\ufe0e Versions \u2693\ufe0e The Data Product Descriptor Specification is versioned using Semantic Versioning 2.0.0 (semver) and follows the semver specification. The major . minor portion of the semver (for example 1.0 ) SHALL designate the DPDS feature set. Typically, .patch versions address errors in this document, not the feature set. Tooling which supports DPDS 1.0 SHOULD be compatible with all DPDS 1.0.* versions. The patch version SHOULD NOT be considered by tooling, making no distinction between 1.0.0 and 1.0.1 for example. Each new minor version of the Data Product Descriptor Specification SHALL allow any Product Descriptor document that is valid against any previous minor version of the Specification, within the same major version, to be updated to the new Specification version with equivalent semantics. Such an update MUST only require changing the dataProductDescriptor property to the new minor version. For example, a valid Data Product Descriptor 1.0.2 document, upon changing its dataProductDescriptor property to 1.1.0 , SHALL be a valid Data Product Descriptor 1.1.0 document, semantically equivalent to the original Data Product Descriptor 1.0.2 document. New minor versions of the Data Product Descriptor Specification MUST be written to ensure this form of backward compatibility. Format \u2693\ufe0e A Data Product Descriptor Document that conforms to the Data Product Descriptor Specification is itself a JSON object, which may be represented either in JSON or YAML format. For example, if a field has an array value, the JSON array representation will be used: { \"field\" : [ 1 , 2 , 3 ] } All field names in the specification are case sensitive . This includes all fields that are used as keys in a map, except where explicitly noted that keys are case insensitive . The schema exposes two types of fields: Fixed fields, which have a declared name, and Patterned fields, which declare a regex pattern for the field name. Patterned fields MUST have unique names within the containing object. In order to preserve the ability to round-trip between YAML and JSON formats, YAML version 1.2 is RECOMMENDED along with some additional constraints: Tags MUST be limited to those allowed by the JSON Schema ruleset . Keys used in YAML maps MUST be limited to a scalar string, as defined by the YAML Failsafe schema ruleset . Document Structure \u2693\ufe0e A Data Product Descriptor Document MAY be made up of a single document or be divided into multiple, connected parts at the discretion of the user. In the latter case a Reference Objects is used. It is RECOMMENDED that the root Data Product Descriptor Document be named: data-product-descriptor.json or data-product-descriptor.yaml . Object Types \u2693\ufe0e A Data Product Descriptor Document have one and only one root object. The properties of an object are described by its fields. A field type can be another object or a primitive type . An addressable and versioned object is called entity. The root object of the Data Product Descriptor Document is an entity object. Other entities that exist only in the scope of the root entity are called components. Data Types \u2693\ufe0e Primitive data types in the DPDS are based on the types supported by the JSON Schema Specification Wright Draft 00 . Primitives have an optional modifier property: format . DPDS uses several known formats to define in fine detail the data type being used. However, to support documentation needs, the format property is an open string -valued property, and can have any value. Formats such as \"email\" , \"uuid\" , and so on, MAY be used even though undefined by this specification. Types that are not accompanied by a format property follow the type definition in the JSON Schema. Tools that do not recognize a specific format MAY default back to the type alone, as if the format is not specified. The formats defined by the DPDS are: type format Comments integer int32 signed 32 bits integer int64 signed 64 bits (a.k.a long) number float number double string string alphanumeric a string that match the following regex ^[a-zA-Z0-9]+$ string name a string that match the following regex ^[a-zA-Z][a-zA-Z0-9]+$ string fqn a string that match the following regex ^[a-zA-Z][a-zA-Z0-9.:]+$ string version a string that match the following regex ^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$ string byte base64 encoded characters string binary any sequence of octets string uuid a sequence of 16 octets as defined by RFC4122 boolean string date As defined by full-date - RFC3339 string date-time As defined by date-time - RFC3339 string password A hint to UIs to obscure input. Rich Text Formatting \u2693\ufe0e Throughout the specification description fields are noted as supporting CommonMark markdown formatting. Where Data Product Descriptor tooling renders rich text it MUST support, at a minimum, markdown syntax as described by CommonMark 0.27 . Tooling MAY choose to ignore some CommonMark features to address security concerns. Relative References in URLs \u2693\ufe0e Unless specified otherwise, all properties that are URLs SHOULD be absolute references. If a property explicitly specify in its description that allows a relative reference its value MUST be compliant with RFC3986 . Relative references MUST be resolved using the URLs defined in the property description as a Base URI. Relative references used in $ref are processed as per JSON Reference , using the URL of the current document as the base URI. See also the Reference Object . Schema \u2693\ufe0e In the following description, if a field is not explicitly REQUIRED or described with a MUST or SHALL, it can be considered OPTIONAL. Data Product Descriptor Entity \u2693\ufe0e This is the root object of the Data Product Descriptor Document . Fixed Fields \u2693\ufe0e Field Name Type Description dataProductDescriptor string:version (REQUIRED) The semantic version number of the Data Product Descriptor Specification Version that the Data Product Descriptor Document uses. The dataProductDescriptor field SHOULD be used by tooling specifications and clients to interpret the Data Product Descriptor Document . This is not related to the data product's info.version field. info Info Object (REQUIRED) The general information about the data product. The information can be used by the platform or by consumers if needed. interfaceComponents Interface Components Object (REQUIRED) The list of all interface entities exposed by the data product. internalComponents Internal Components Object The list of all internal entities that compose the data product. components Components Object An element to hold a set of reusable objects that can be referentiated in other part of the document. tags [ string ] A list of tags associated to the data product. Tags can be used for logical grouping of data products. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Info Object \u2693\ufe0e The Info Object contains general information about the data product. The information can be used by the platform or by consumers if needed. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 ( RFC-4122 ) generated server side during data product creation as SHA-1 hash of the fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to referentiate the data product. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to referentiate the data product when calling an API different from the ones exposed by the data product experience plane the fullyQualifiedName MUST be always used. Example: \"id: \"2b172838-73b1-5d6c-be45-cc75aee180a0\" fullyQualifiedName string:fqn (REQUIRED) The unique universal idetifier of the data product. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version} . It's RECOMMENDED to use as mesh-namespace your company's domain name in reverse dot notation (es it.quantyca ) in order to ensure that the fullyQualifiedName is unique universal idetifier as REQUIRED. To the mesh-nemaspace MAY be added as postfix the product's 'domain' (es. planning , operations , ...). Using the data product's domain as postfix in the mesh-namespace is anyway NOT RECOMMENDED. Example: \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1\" . entityType string:alphanumeric (READONLY) The type of the entity. It MUST be a constant value equals to dataproduct . name string:name (REQUIRED) The name of the data product. MUST be unique within the mesh-namespace . It's RECOMMENDED to use a camel case formatted string. version string:version (REQUIRED) The semantic version number of the data product definition contained in the given Data Product Descriptor Document . Everytime the major version of one of the data product's ports changes also the major version of the product MUST be incremented. It is RECOMMENDED to use 0 as major version for data products that are not yet general available. These data products can introduce breaking changes without incrementing their major version . It is anyway RECOMMENDED that for every breaking change introduced by a data product that is not yet general available (i.e. major version equals to 0) at least the minor version is incremented. This field is not related to the dataProductDescriptor field. displayName string The human readable name of the data product. It SHOULD be used by frontend tool to visualize data product's name in place of the name property. It's RECOMMENDED to not use the same displayName for different data products belonging to the same mesh-namespace . description string The data product description. CommonMark syntax MAY be used for rich text representation. domain string:name (REQUIRED) The domain to which the data product belongs to. owner Owner Object A collection of information related to the data product's owner. contactPoints [ Contact Point Object ] A collection of contact information for the given data product. This object MAY be extended with Specification Extensions . Owner Object \u2693\ufe0e The Owner Object describes the data product's owner. Fixed Fields \u2693\ufe0e Field Name Type Description id string (REQUIRED) The identifier of the data product's owner. It's RECOMMENDED to use the corporate mail of the owner as identifier. name string The full name of the data product's owner This object MAY be extended with Specification Extensions . Owner Object Example: \u2693\ufe0e { \"id\" : \"john.doe@company-xyz.com\" , \"name\" : \"John Doe\" } Contact Point Object \u2693\ufe0e The Contact Point Object describes a data product's contact point. Fixed Fields \u2693\ufe0e Field Name Type Description name string:name The name of the contact point. description string The contact point description. CommonMark syntax MAY be used for rich text representation. channel string The channel used to address the contact point. It can be for example equal to web , mail or phone . address string The address of the contact point. Depending on the channel it can be for example an URL, an email address or a phone number. This object MAY be extended with Specification Extensions . Contact Point Object Example: \u2693\ufe0e { \"name\" : \"Support Team Mail\" , \"description\" : \"The mail address of to the team that give support on this product\" , \"channel\" : \"email\" , \"address\" : \"trip-execution-support@company-xyz.com\" } { \"name\" : \"Issue Tracker\" , \"description\" : \"The address of the issue tracker associated to this product\" , \"channel\" : \"web\" , \"address\" : \"https://readmine.company-xyz.com/trip-execution\" } Interface Components Object \u2693\ufe0e The Interface Components Object it's a collection of all interface entities exposed by a data product. Fixed Fields \u2693\ufe0e Field Name Type Description inputPorts [ Input Port Component | Reference Object ] The input ports exposed by the data product. outputPorts [ Output Port Component | Reference Object ] (REQUIRED) The output ports exposed by the data product. discoveryPorts [ Discovery Port Component | Reference Object ] The discovery ports exposed by the data product. observabilityPorts [ Observability Port Component | Reference Object ] The observability ports exposed by the data product. controlPorts [ Control Port Component | Reference Object ] The control ports exposed by the data product. This object cannot be extended with additional properties and any properties added SHALL be ignored. Input Port Component \u2693\ufe0e The Input Port Component describes an input port of a data product. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the port's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to referentiate the port. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to referentiate the data product when calling API different from the ones exposed by the data product experience plane the port's fullyQualifiedName MUST be always used. Example: \"id\": \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) . The unique universal idetifier of the port. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:inputports:{port-name} . Example: \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:inputports:tmsTripCDC\" . entityType string:alphanumeric The type of the entity. It MUST be a constant value equals to inputport . name string:name (REQUIRED) The name of the port. It MUST be unique within the other input ports of the same data product. It's RECOMMENDED to use a cammel case formatted string. Example \"name: \"tmsTripCDC\" . version string:version (REQUIRED) The semantic version number of the data product's port. Everytime the major version of port changes also the major version of the product MUST be incremented. displayName string The human readable name of the port. It SHOULD be used by frontend tool to visualize port's name in place of the name property. It's RECOMMENDED to not use the same displayName for different input ports belonging to the same data product. description string The port descripion. CommonMark syntax MAY be used for rich text representation. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. promises Promises Object | Reference Object The data product's promises declared over the port. expectations Expectation Object | Reference Object The data product's expectations declared over the port. contracts Contracts Object | Reference Object The data product's contracts declared over the port. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Output Port Component \u2693\ufe0e The Output Port Component describes an output port of a data product. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the port's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to referentiate the port. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to referentiate the data product when calling API different from the ones exposed by the data product experience plane the port's fullyQualifiedName MUST be always used. Example: \"id\": \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) The unique universal idetifier of the port. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:inputports:{port-name} . Example \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:inputports:tmsTripCDC\" . entityType string:alphanumeric The type of the entity. It MUST be a constant value equals to outputport . name string:name (REQUIRED) The name of the port. MUST be unique within the other input ports of the same data product. It's RECOMMENDED to use a cammel case formatted string. Example \"name: \"tmsTripCDC\" . version string:version (REQUIRED) The semantic version number of the data product's port. Everytime the major version of port changes also the major version of the product MUST be incremented. displayName string The human readable name of the port. It SHOULD be used by frontend tool to visualize port's name in place of the name property. It's RECOMMENDED to not use the same displayName for different input ports belonging to the same data product. description string The port descripion. CommonMark syntax MAY be used for rich text representation. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. promises Promises Object | Reference Object The data product's promises declared over the port. expectations Expectation Object | Reference Object The data product's expectations declared over the port. contracts Contracts Object | Reference Object The data product's contracts declared over the port. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Discovey Port Component \u2693\ufe0e The Discovey Port Component describes a discovery port of a data product. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the port's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to referentiate the port. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to referentiate the data product when calling API different from the ones exposed by the data product experience plane the port's fullyQualified name MUST be always used. \"id: \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) . The unique universal idetifier of the port. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:inputports:{port-name} . Example \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:inputports:tmsTripCDC\" . entityType string:alphanumeric The type of the entity. It MUST be a constant value equals to discoveryport . name string:name (REQUIRED) The name of the port. MUST be unique within the other input ports of the same data product. It's RECOMMENDED to use a cammel case formatted string. Example \"name: \"tmsTripCDC\" . version string:version (REQUIRED) The semantic version number of the data product's port. Everytime the major version of port changes also the major version of the product MUST be incremented. displayName string The human readable name of the port. It SHOULD be used by frontend tool to visualize port's name in place of the name property. It's RECOMMENDED to not use the same displayName for different input ports belonging to the same data product. description string The port descripion. CommonMark syntax MAY be used for rich text representation. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. promises Promises Object | Reference Object The data product's promises declared over the port. expectations Expectation Object | Reference Object The data product's expectations declared over the port. contracts Contracts Object | Reference Object The data product's contracts declared over the port. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Observability Port Component \u2693\ufe0e The Observability Port Component describes an observability port of a data product. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the port's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to referentiate the port. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to referentiate the data product when calling API different from the ones exposed by the data product experience plane the port's fullyQualified name MUST be always used. \"id: \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) The unique universal idetifier of the port. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:inputports:{port-name} . Example \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:inputports:tmsTripCDC\" . entityType string:alphanumeric The type of the entity. It MUST be a constant value equals to observabilityport . name string:name (REQUIRED) The name of the port. MUST be unique within the other input ports of the same data product. It's RECOMMENDED to use a cammel case formatted string. Example \"name: \"tmsTripCDC\" . version string:version (REQUIRED) The semantic version number of the data product's port. Everytime the major version of port changes also the major version of the product MUST be incremented. displayName string The human readable name of the port. It SHOULD be used by frontend tool to visualize port's name in place of the name property. It's RECOMMENDED to not use the same displayName for different input ports belonging to the same data product. description string The port descripion. CommonMark syntax MAY be used for rich text representation. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. promises Promises Object | Reference Object The data product's promises declared over the port. expectations Expectation Object | Reference Object The data product's expectations declared over the port. contracts Contracts Object | Reference Object The data product's contracts declared over the port. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Control Port Component \u2693\ufe0e The Control Port Component describes a control port of a data product. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the port's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to referentiate the port. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to referentiate the data product when calling API different from the ones exposed by the data product experience plane the port's fullyQualified name MUST be always used. \"id: \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) . The unique universal idetifier of the port. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:inputports:{port-name} . Example \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:inputports:tmsTripCDC\" . entityType string:alphanumeric The type of the entity. It MUST be a constant value equals to controlport . name string:name (REQUIRED) The name of the port. MUST be unique within the other input ports of the same data product. It's RECOMMENDED to use a cammel case formatted string. Example \"name: \"tmsTripCDC\" . version string:version (REQUIRED) The semantic version number of the data product's port. Everytime the major version of port changes also the major version of the product MUST be incremented. displayName string The human readable name of the port. It SHOULD be used by frontend tool to visualize port's name in place of the name property. It's RECOMMENDED to not use the same displayName for different input ports belonging to the same data product. description string The port descripion. CommonMark syntax MAY be used for rich text representation. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. promises Promises Object | Reference Object The data product's promises declared over the port. expectations Expectation Object | Reference Object The data product's expectations declared over the port. contracts Contracts Object | Reference Object The data product's contracts declared over the port. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Promises Object \u2693\ufe0e The Promises Object describes the data product's promises declared over a given port. Fixed Fields \u2693\ufe0e Field Name Type Description platform string The target technological platform in which the services associated with the given port operate. It contains usually the infrastructure provider and data center location. Optionally it can contains also the specific runtime technology used. Examples: onprem:milan-1 , aws:eu-south-1 , aws:eu-south-1:redshift . servicesType string The type of services associated with the given port. Examples: soap-services , rest-services , odata-services , streaming-services , datastore-services . api Standard Definition Object The formal description of port's services API. It is RECOMMENDED to use Open API Specification for restfull services, Async API Specification for streaming services and DataStore API Specification for data store connection based services. Other specifications MAY be used as required. depreceationPolicy Specification Extension Point The deprecation policy adopted by the port. It is RECOMMENDED to specify at least how long the deprecation period will be after the release of a new major version. slo Specification Extension Point The service level objectives supported by the port. It is RECOMMENDED to group SLO by category (ex. operational SLO, quality SLO, etc ...) and specify them in an easy to compute way. This object MAY be extended with Specification Extensions . Expectations Object \u2693\ufe0e The Expectations Object describes the data product's expectations declared over a given port. Fixed Fields \u2693\ufe0e Field Name Type Description audience Specification Extension Point The audience of consumers for whom the the port has been designed. It is RECOMMENDED to specify inclusion and exclusion criteria in a way that is not ambiguous. usage Specification Extension Point The usage patterns for which the port has been designed. This object MAY be extended with Specification Extensions . Contracts Object \u2693\ufe0e The Contracts Object describes the data product's contracts declared over a given port. Fixed Fields \u2693\ufe0e Field Name Type Description termsAndConditions Specification Extension Point The terms and conditions defined on the port on which consumers must agree on and respect in order to use it. billingPolicy Specification Extension Point The billing policy defined on the port on which consumers must agree on and respect in order to use it. sla Specification Extension Point The service level agreements supported by the port. It is RECOMMENDED to group SLA by category (ex. operational SLA, quality SLA, ecc ...) and specify them in an easy to compute way. This object MAY be extended with Specification Extensions . Internal Components Object \u2693\ufe0e The Internal Components Object it's a collection of all internal entities that compose a data product. Fixed Fields \u2693\ufe0e Field Name Type Description applicationComponents [ Application Component ] The list of application component that compose the data product. infrastructuralComponents [ Infrastructural Component ] The list of infrastructural components that compose the data product. This object cannot be extended with additional properties and any properties added SHALL be ignored. Application Component \u2693\ufe0e The Application Component describes an internal application component used by the data product to provide services through its ports. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the component's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to address the component. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to address the component when calling API different from the ones exposed by the data product experience plane the component's fullyQualifiedName MUST be always used. Examples: \"id: \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) . The unique universal idetifier of the component. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:applications:{app-name} . Example \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:applications:modelNormalizationJob\" . entityType string:alphanumeric (READONLY) The type of the entity. It is a constant value equals to application . name string:name The name of the application component. MUST be unique within the other application components of the same data product. It's RECOMMENDED to use a camel case formatted string. Example \"name: \"modelNormalizationJob\" . version string:version (REQUIRED) The semantic version number of the data product's application component. displayName string The human readable name of the component. It SHOULD be used by frontend tool to visualize application component's name in place of the name property. It's RECOMMENDED to not use the same displayName for different application component belonging to the same data product. description string The application component description. CommonMark syntax MAY be used for rich text representation. platform string The target technological platform on which the application will be deployed. It contains usually the infrastructure provider and data center location. Optionally it can contains also the specific runtime technology used. Examples: onprem:milan-1 , aws:eu-south-1 , aws:eu-south-1:redshift . applicationType string The type of the application: Examples: stream-sourcing , batch-sourcing , streaming-transformation , batch-transformation , housekeeping , ecc... buildInfo Build Info Object The information required to build the application component. deployInfo Deploy Info Object The information required to deploy the application component. consumesFrom [ string:fqn ] The list of ports or infrastructural components from which the application consumes directly data or services. providesTo [ string:fqn ] The list of ports or infrastructural components to which the application provides directly data or services. dependsOn [ string:fqn ] A list of other internal components on which this application directly depends on. It is used during data product deployment to define a consistent deployment plan. Cyclic dependencies between components MUST be avoided. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Build Info Object \u2693\ufe0e The Build Info Object contains all the informations required to build an Application Component Fixed Fields \u2693\ufe0e Field Name Type Description service string:name | External Resource Object The logical name or the actual endpoint of the service to call in order to build the application component. If the logical name is used as field value the actual endpoint value resulution is demanded to the data product experience plane of the underlyng platform. buildTemplate object | Reference Object | External Resource Object Can be an inline JSON or a refernce to an external resource. It contains the definition of the pipeline to execute in order to build the application. It is passed as is to the build service specified using the buildService field. buildConfigurations object | Reference Object | External Resource Object Can be an inline JSON or a refernce to an external resource. It contains the configuration properties that can be used by the build service at build time. It is passed as is to the build service specified using the buildService field. This object MAY be extended with Specification Extensions . Deploy Info Object \u2693\ufe0e The Deploy Info Object contains all the informations required to deploy an Application Component Fixed Fields \u2693\ufe0e Field Name Type Description service string:name | External Resource Object The logical name or the actual endpoint of the service to call in order to deploy the application component. If the logical name is used as field value the actual endpoint value resulution is demanded to the data product experience plane of the underlyng platform. template object | Reference Object | External Resource Object Can be an inline JSON or a refernce to an external resource. It contains the definition of the pipeline to execute in order to deploy the application. It is passed as is to the deployment service specified using the deploymentService field. configurations object | Reference Object | External Resource Object Can be an inline JSON or a refernce to an external resource. It contains the configuration properties that can be used by the deployment service at deploy time. It is passed as is to the deployment service specified using the deploymentService field. This object MAY be extended with Specification Extensions . Infrastructural Component \u2693\ufe0e The Infrastructural Component describes an internal infrastructural component used by the data product to run its applications and store its data. Fixed Fields \u2693\ufe0e Field Name Type Description id string:uuid (READONLY) It's an UUID version 3 (see RFC-4122 ) generated server side during data product creation as SHA-1 hash of the component's fullyQualifiedName . It MAY be used when calling the API exposed by the data product experience plane to address the component. Because the fullyQualifiedName is globally unique also the id is globally unique, anyway to address the component when calling API different from the ones exposed by the data product experience plane the component's fullyQualifiedName MUST be always used. Examples: \"id: \"3235744b-8d2e-57b5-afba-f66862cc6a21\" fullyQualifiedName string:fqn (REQUIRED) . The unique universal idetifier of the component. It MUST be a URN of the form urn:dpds:{mesh-namespace}:dataproducts:{product-name}:{product-major-version}:infrastructure:{infra-name} . Example \"fullyQualifiedName: \"urn:dpds:it.quantyca:dataproducts:tripExecution:1:infrastructure:stagingArea\" . entityType string:alphanumeric (READONLY) The type of the entity. It is a constant value equals to infrastructure . name string:name The name of the infrastructural component. MUST be unique within the other infrastructural components of the same data product. It's RECOMMENDED to use a camel case formatted string. Example \"name: \"stagingArea\" . version string:version (REQUIRED) The semantic version number of the data product's infrastructural component. displayName string The human readable name of the component. It SHOULD be used by frontend tool to visualize application component's name in place of the name property. It's RECOMMENDED to not use the same displayName for different infrastructural component belonging to the same data product. description string The infrastructural component descripion. CommonMark syntax MAY be used for rich text representation. platform string The target technological platform on which the infrastructural component will be provisioned. It contains usually the infrastructure provider and data center location. Optionally it can contains also the specific resource object that will be provisioned. Examples: onprem:milan-1 , aws:eu-south-1 , aws:eu-south-1:s3-buket . infrastructureType string The type of the infrastructural component. Examples: computation-resource , storage-resource , networking-resource , ecc... provisionInfo Provision Info Object The information required to provision the infrastructural component. dependsOn [ string:fqn ] A list of other infrastructural components on which this component directly depends on. It is used during infrastructure provisioning to define a consistent provisioning plan. Cyclic dependencies between infrastructural components MUST be avoided. componentGroup string:name The name of the group this component belongs to. Grouping different components together is useful to define sub modules withing a data product. A sub module can be used as base for creating reusable templates. tags [ string ] A list of tags associated to the component. Tags can be used for logical grouping of data product's components. externalDocs External Resource Object Additional external documentation. This object MAY be extended with Specification Extensions . Provision Info Object \u2693\ufe0e The Provision Info Object contains all the informations required to provision an Infrastructural Component Fixed Fields \u2693\ufe0e Field Name Type Description service string:name | External Resource Object The logical name or the actual endpoint of the service to call in order to provision the infrastructural component. If the logical name is used as field value the actual endpoint value resulution is demanded to the data product experience plane of the underlyng platform. template object | Reference Object | External Resource Object Can be an inline JSON or a refernce to an external resource. It contains the definition of the resources to provision. It is passed as is to the provisioning service specified using the provisionService field. configurations object | Reference Object | External Resource Object Can be an inline JSON or a refernce to an external resource. It contains the configuration properties that can be used by the provisioning service at provision time. It is passed as is to the provision service specified using the provisioningService field. This object MAY be extended with Specification Extensions . Components Object \u2693\ufe0e The Components Object holds a set of reusable objects for different aspects of the DPDS. All objects defined within the components object will have no effect on the Data Product Descriptor unless they are explicitly referenced from properties outside the components object. Fixed Fields \u2693\ufe0e Field Name Type Description inputPorts Map[ string , Input Port Component | Reference Object ] An object to hold reusable Input Port Component . outputPorts Map[ string , Output Port Component | Reference Object ] An object to hold reusable Output Port Component . discoveryPorts Map[ string , Discovery Port Component | Reference Object ] An object to hold reusable Discovery Port Component . observabilityPorts Map[ string , Observability Port Component | Reference Object ] An object to hold reusable Observability Port Component . controlPorts Map[ string , Control Port Component | Reference Object ] An object to hold reusable Control Port Component . applicationComponents Map[ string , Application Component | Reference Object ] An object to hold reusable Application Component . infrastructuralComponents Map[ string , Infrastructural Component | Reference Object ] An object to hold reusable Infrastructural Component . This object MAY be extended with Specification Extensions . All the fixed fields declared above are objects that MUST use keys that match the regular expression: ^[a-zA-Z0-9\\.\\-_]+$ . Reference Object \u2693\ufe0e The Reference Object allows referencing other components in the Data Product Descriptor Document , internally and externally. The $ref string value contains a URI RFC3986 , which identifies the location of the value being referenced. See the rules for resolving Relative References . Fixed Fields \u2693\ufe0e Field Name Type Description description string A description which by default SHOULD override that of the referenced component. CommonMark syntax MAY be used for rich text representation. If the referenced object-type does not allow a description field, then this field has no effect. $ref string REQUIRED . The reference identifier. This MUST be in the form of a URI. This object cannot be extended with additional properties and any properties added SHALL be ignored. Reference Object Example \u2693\ufe0e { \"$ref\" : \"#/components/schemas/Pet\" } Relative Schema Document Example \u2693\ufe0e { \"$ref\" : \"Pet.json\" } Relative Documents With Embedded Schema Example \u2693\ufe0e { \"$ref\" : \"definitions.json#/Pet\" } External Resource Object \u2693\ufe0e The External Resource Object allows referencing an external resource like a documentation page or a standard definition. Fixed Fields \u2693\ufe0e Field Name Type Description description string A description of the target resource. CommonMark syntax MAY be used for rich text representation. mediaType string The media type of target resource. It must conform to media type format, according to RFC6838 . $href string:uri REQUIRED . The URI of the target resource. It must conform to the URI format, according to RFC3986 . This object cannot be extended with additional properties and any properties added SHALL be ignored. External Resource Object Example \u2693\ufe0e { \"description\" : \"Find more info here\" , \"mediaType\" : \"text/html\" , \"$href\" : \"https://example.com\" } Standard Definition Object \u2693\ufe0e The Standard Definition Object formally describes an object (ex. API object, provision template object, ecc ...) of interest following a given standard specification. Fixed Fields \u2693\ufe0e Field Name Type Description description string The standard definition descripion. CommonMark syntax MAY be used for rich text representation. specification string (REQUIRED) The external specification used in the definition . version string The version of the external specification used in the definition . If not defined the version MUST be included in the definition itself. definition object | Reference Object | External Resource Object (REQUIRED) The formal definition built using the spcification declared in the [specification](#standardDefinitionSpecification) field. externalDocs External Resource Object Additional external documentation for the standard definition. This object MAY be extended with Specification Extensions . Standard Definition Object Example: \u2693\ufe0e { \"description\" : \"The API exposed by the Observability Port that exposes data product logs\" , \"specification\" : \"openapi\" , \"version\" : \"3.1.0\" , \"definition\" : { \"mediaType\" : \"text/json\" , \"$href\" : \"https://mycompany.com/api/v1/planes/utility/logging-services/openapi.json\" }, \"externalDocs\" : { \"mediaType\" : \"text/html\" , \"$href\" : \"https://spec.openapis.org/oas/v3.1.0\" } } Specification Extension Point \u2693\ufe0e A Specification Extension Point marks specific part of the Data Product Descriptor Specification that are left open to extensions or futher evolution of the standard. While a Standard Definition it's a formal declaration that the description of a part of the Data Product Descriptor Specification will be demanded to an external standards in this verion of the specification and in the future ones, the same assumption it's not true for Specification Extension Point . Even if a Specification Extension Point can be extended at will it is RECOMMENDED to use for all added properties a field name prefixed by \"x-\" in order to avoid potetntial conflicts with future versions of the Data Product Descriptor Specification . Fixed Fields \u2693\ufe0e Field Name Type Description description string The extention point descripion. CommonMark syntax MAY be used for rich text representation. externalDocs External Resource Object Additional external documentation for the extention point This object MAY be extended with Specification Extensions . Specification Extensions \u2693\ufe0e While the Data Product Descriptor Specification tries to accommodate most use cases, additional data can be added to extend the specification at certain points. The extensions properties are implemented as patterned fields that are always prefixed by \"x-\" . Field Pattern Type Description ^x- Any Allows extensions to the Data Product Descriptor Schema. The field name MUST begin with x- , for example, x-internal-id . The value can be null , a primitive, an array or an object. Can have any valid JSON format value. The extensions may or may not be supported by the available tooling, but those may be extended as well to add requested support (if tools are internal or open-sourced). Appendix A: Revision History \u2693\ufe0e Version Date Notes 1.0.0 2022-11-01 Release of the Data Product Descriptor Specification 1.0.0","title":"Data Product Descriptor Specification"},{"location":"references/specifications/last/#data-product-descriptor-specification","text":"","title":"Data Product Descriptor Specification"},{"location":"references/specifications/last/#version-100","text":"The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 RFC2119 RFC8174 when, and only when, they appear in all capitals, as shown here. This document is licensed under The Apache License, Version 2.0 .","title":"Version 1.0.0"},{"location":"references/specifications/last/#disclaimer","text":"Part of this content has been taken from the great work done by the folks at the OpenAPI Initiative and AsyncAPI Initiative . We have decided to not reinvent the wheel and inspire our work to these two specifications mainly for the following reasons: We think that the work made by OpenAPI Initiative and AsyncAPI Initiative is great :) We want to make the learning curve for the Data Product Descriptor Specification as smooth as possible, aligning its definition to the one of other two popular specifications in the software and data engineers community We think that OpenAPI and AsyncAPI are natural specifications for defining the interface of data product's ports that expose an API endpoint. This specification do not impose to use any specific standard for port's interface definition but these two are highly recommended.","title":"Disclaimer"},{"location":"references/specifications/last/#introduction","text":"The Data Product Descriptor Specification (DPDS) defines a declarative and technology independent standard to describe a data product in all its components. It allows human agents (e.g. analysts, data scientists, etc..) and digital agents (e.g. other data products, BI tools, planes of the underlying data mesh ops platform, etc..) to operate, discover and access a data product. When properly defined, an external agent can understand and interact with the data product with a minimal amount of cognitive load and implementation logic. The formalization of a standard data product descriptor document through an open specification is useful to enable the implementation of an ecosystem of interoperable data mesh tools. The following is a non exhaustive list of tools that can benefit from the specification: catalogs (search, document and collaborate) design tools (create new products by composition of reusable templates) lifecycle management tools (deploy and operate) access management tools (assign/track access grants and generate client code in different languages) policies checking tools (enforce standard compliance and audit security) observability tools (monitor and detect) data lineage tools (trace data flows and perform forward/backward analysis) mesh topology analysis tools (calculate value/trust scores and detect structural problems) semantic tools (apply ontologies over mesh topology) domain specific language tools (create a collection af interconnected data products that implement together a specific value stream)","title":"Introduction"},{"location":"references/specifications/last/#table-of-contents","text":"Definitions Standard Standard Specification Standard Definition Data Product Data Product Ports Data Product Application Components Data Product Infrastructural Components Data Product Descriptor Document Data Product Descriptor Specification Specification Versions Format Document Structure Data Types Rich Text Formatting Relative References In URLs Schema Data Product Descriptor Entity Info Object Owner Object Contact Point Object Interface Components Object Input Port Component Output Port Component Discovery Port Component Observability Port Component Control Port Component Promises Object Expectations Object Contracts Object Internal Components Object Application Component Build Info Object Deploy Info Object Infrastructural Component Provision Info Object Components Object Reference Object External Resource Object Standard Definition Object Specification Extension Point Specification Extensions Appendix A: Revision History","title":"Table of Contents"},{"location":"references/specifications/last/#definitions","text":"","title":"Definitions"},{"location":"references/specifications/last/#specification","text":"","title":"Specification"},{"location":"references/specifications/last/#versions","text":"The Data Product Descriptor Specification is versioned using Semantic Versioning 2.0.0 (semver) and follows the semver specification. The major . minor portion of the semver (for example 1.0 ) SHALL designate the DPDS feature set. Typically, .patch versions address errors in this document, not the feature set. Tooling which supports DPDS 1.0 SHOULD be compatible with all DPDS 1.0.* versions. The patch version SHOULD NOT be considered by tooling, making no distinction between 1.0.0 and 1.0.1 for example. Each new minor version of the Data Product Descriptor Specification SHALL allow any Product Descriptor document that is valid against any previous minor version of the Specification, within the same major version, to be updated to the new Specification version with equivalent semantics. Such an update MUST only require changing the dataProductDescriptor property to the new minor version. For example, a valid Data Product Descriptor 1.0.2 document, upon changing its dataProductDescriptor property to 1.1.0 , SHALL be a valid Data Product Descriptor 1.1.0 document, semantically equivalent to the original Data Product Descriptor 1.0.2 document. New minor versions of the Data Product Descriptor Specification MUST be written to ensure this form of backward compatibility.","title":" Versions"},{"location":"references/specifications/last/#format","text":"A Data Product Descriptor Document that conforms to the Data Product Descriptor Specification is itself a JSON object, which may be represented either in JSON or YAML format. For example, if a field has an array value, the JSON array representation will be used: { \"field\" : [ 1 , 2 , 3 ] } All field names in the specification are case sensitive . This includes all fields that are used as keys in a map, except where explicitly noted that keys are case insensitive . The schema exposes two types of fields: Fixed fields, which have a declared name, and Patterned fields, which declare a regex pattern for the field name. Patterned fields MUST have unique names within the containing object. In order to preserve the ability to round-trip between YAML and JSON formats, YAML version 1.2 is RECOMMENDED along with some additional constraints: Tags MUST be limited to those allowed by the JSON Schema ruleset . Keys used in YAML maps MUST be limited to a scalar string, as defined by the YAML Failsafe schema ruleset .","title":" Format"},{"location":"references/specifications/last/#document-structure","text":"A Data Product Descriptor Document MAY be made up of a single document or be divided into multiple, connected parts at the discretion of the user. In the latter case a Reference Objects is used. It is RECOMMENDED that the root Data Product Descriptor Document be named: data-product-descriptor.json or data-product-descriptor.yaml .","title":"Document Structure"},{"location":"references/specifications/last/#object-types","text":"A Data Product Descriptor Document have one and only one root object. The properties of an object are described by its fields. A field type can be another object or a primitive type . An addressable and versioned object is called entity. The root object of the Data Product Descriptor Document is an entity object. Other entities that exist only in the scope of the root entity are called components.","title":"Object Types"},{"location":"references/specifications/last/#data-types","text":"Primitive data types in the DPDS are based on the types supported by the JSON Schema Specification Wright Draft 00 . Primitives have an optional modifier property: format . DPDS uses several known formats to define in fine detail the data type being used. However, to support documentation needs, the format property is an open string -valued property, and can have any value. Formats such as \"email\" , \"uuid\" , and so on, MAY be used even though undefined by this specification. Types that are not accompanied by a format property follow the type definition in the JSON Schema. Tools that do not recognize a specific format MAY default back to the type alone, as if the format is not specified. The formats defined by the DPDS are: type format Comments integer int32 signed 32 bits integer int64 signed 64 bits (a.k.a long) number float number double string string alphanumeric a string that match the following regex ^[a-zA-Z0-9]+$ string name a string that match the following regex ^[a-zA-Z][a-zA-Z0-9]+$ string fqn a string that match the following regex ^[a-zA-Z][a-zA-Z0-9.:]+$ string version a string that match the following regex ^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$ string byte base64 encoded characters string binary any sequence of octets string uuid a sequence of 16 octets as defined by RFC4122 boolean string date As defined by full-date - RFC3339 string date-time As defined by date-time - RFC3339 string password A hint to UIs to obscure input.","title":"Data Types"},{"location":"references/specifications/last/#rich-text-formatting","text":"Throughout the specification description fields are noted as supporting CommonMark markdown formatting. Where Data Product Descriptor tooling renders rich text it MUST support, at a minimum, markdown syntax as described by CommonMark 0.27 . Tooling MAY choose to ignore some CommonMark features to address security concerns.","title":"Rich Text Formatting"},{"location":"references/specifications/last/#relative-references-in-urls","text":"Unless specified otherwise, all properties that are URLs SHOULD be absolute references. If a property explicitly specify in its description that allows a relative reference its value MUST be compliant with RFC3986 . Relative references MUST be resolved using the URLs defined in the property description as a Base URI. Relative references used in $ref are processed as per JSON Reference , using the URL of the current document as the base URI. See also the Reference Object .","title":"Relative References in URLs"},{"location":"references/specifications/last/#schema","text":"In the following description, if a field is not explicitly REQUIRED or described with a MUST or SHALL, it can be considered OPTIONAL.","title":"Schema"},{"location":"references/specifications/last/#data-product-descriptor-entity","text":"This is the root object of the Data Product Descriptor Document .","title":"Data Product Descriptor Entity"},{"location":"references/specifications/last/#info-object","text":"The Info Object contains general information about the data product. The information can be used by the platform or by consumers if needed.","title":"Info Object"},{"location":"references/specifications/last/#owner-object","text":"The Owner Object describes the data product's owner.","title":"Owner Object"},{"location":"references/specifications/last/#contact-point-object","text":"The Contact Point Object describes a data product's contact point.","title":"Contact Point Object"},{"location":"references/specifications/last/#interface-components-object","text":"The Interface Components Object it's a collection of all interface entities exposed by a data product.","title":"Interface Components Object"},{"location":"references/specifications/last/#input-port-component","text":"The Input Port Component describes an input port of a data product.","title":"Input Port Component"},{"location":"references/specifications/last/#output-port-component","text":"The Output Port Component describes an output port of a data product.","title":"Output Port Component"},{"location":"references/specifications/last/#discovey-port-component","text":"The Discovey Port Component describes a discovery port of a data product.","title":"Discovey Port Component"},{"location":"references/specifications/last/#observability-port-component","text":"The Observability Port Component describes an observability port of a data product.","title":"Observability Port Component"},{"location":"references/specifications/last/#control-port-component","text":"The Control Port Component describes a control port of a data product.","title":"Control Port Component"},{"location":"references/specifications/last/#promises-object","text":"The Promises Object describes the data product's promises declared over a given port.","title":"Promises Object"},{"location":"references/specifications/last/#expectations-object","text":"The Expectations Object describes the data product's expectations declared over a given port.","title":"Expectations Object"},{"location":"references/specifications/last/#contracts-object","text":"The Contracts Object describes the data product's contracts declared over a given port.","title":"Contracts Object"},{"location":"references/specifications/last/#internal-components-object","text":"The Internal Components Object it's a collection of all internal entities that compose a data product.","title":"Internal Components Object"},{"location":"references/specifications/last/#application-component","text":"The Application Component describes an internal application component used by the data product to provide services through its ports.","title":"Application Component"},{"location":"references/specifications/last/#build-info-object","text":"The Build Info Object contains all the informations required to build an Application Component","title":"Build Info Object"},{"location":"references/specifications/last/#deploy-info-object","text":"The Deploy Info Object contains all the informations required to deploy an Application Component","title":"Deploy Info Object"},{"location":"references/specifications/last/#infrastructural-component","text":"The Infrastructural Component describes an internal infrastructural component used by the data product to run its applications and store its data.","title":"Infrastructural Component"},{"location":"references/specifications/last/#provision-info-object","text":"The Provision Info Object contains all the informations required to provision an Infrastructural Component","title":"Provision Info Object"},{"location":"references/specifications/last/#components-object","text":"The Components Object holds a set of reusable objects for different aspects of the DPDS. All objects defined within the components object will have no effect on the Data Product Descriptor unless they are explicitly referenced from properties outside the components object.","title":"Components Object"},{"location":"references/specifications/last/#reference-object","text":"The Reference Object allows referencing other components in the Data Product Descriptor Document , internally and externally. The $ref string value contains a URI RFC3986 , which identifies the location of the value being referenced. See the rules for resolving Relative References .","title":"Reference Object"},{"location":"references/specifications/last/#external-resource-object","text":"The External Resource Object allows referencing an external resource like a documentation page or a standard definition.","title":"External Resource Object"},{"location":"references/specifications/last/#standard-definition-object","text":"The Standard Definition Object formally describes an object (ex. API object, provision template object, ecc ...) of interest following a given standard specification.","title":"Standard Definition Object"},{"location":"references/specifications/last/#specification-extension-point","text":"A Specification Extension Point marks specific part of the Data Product Descriptor Specification that are left open to extensions or futher evolution of the standard. While a Standard Definition it's a formal declaration that the description of a part of the Data Product Descriptor Specification will be demanded to an external standards in this verion of the specification and in the future ones, the same assumption it's not true for Specification Extension Point . Even if a Specification Extension Point can be extended at will it is RECOMMENDED to use for all added properties a field name prefixed by \"x-\" in order to avoid potetntial conflicts with future versions of the Data Product Descriptor Specification .","title":"Specification Extension Point"},{"location":"references/specifications/last/#specification-extensions","text":"While the Data Product Descriptor Specification tries to accommodate most use cases, additional data can be added to extend the specification at certain points. The extensions properties are implemented as patterned fields that are always prefixed by \"x-\" . Field Pattern Type Description ^x- Any Allows extensions to the Data Product Descriptor Schema. The field name MUST begin with x- , for example, x-internal-id . The value can be null , a primitive, an array or an object. Can have any valid JSON format value. The extensions may or may not be supported by the available tooling, but those may be extended as well to add requested support (if tools are internal or open-sourced).","title":"Specification Extensions"},{"location":"references/specifications/last/#appendix-a-revision-history","text":"Version Date Notes 1.0.0 2022-11-01 Release of the Data Product Descriptor Specification 1.0.0","title":"Appendix A: Revision History"}]}